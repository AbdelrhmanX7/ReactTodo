"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = SortableList;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Demo:
 * https://codepen.io/catamphetamine/pen/qBWxEQX
 *
 * `itemComponent` receives properties:
 * `dragging: boolean` — Is `true` when some item is being dragged.
 * `dragged: boolean` — Is `true` when this item is being dragged.
 * `style: object` — The `style` that must be set on the item root element.
 */
function SortableList(_ref) {
  var items = _ref.value,
      onChange = _ref.onChange,
      Component = _ref.component,
      ItemComponent = _ref.itemComponent,
      itemComponentProps = _ref.itemComponentProps,
      dragHandleDataAttribute = _ref.dragHandleDataAttribute,
      animationDuration = _ref.animationDuration,
      animationEasing = _ref.animationEasing,
      rest = _objectWithoutProperties(_ref, ["value", "onChange", "component", "itemComponent", "itemComponentProps", "dragHandleDataAttribute", "animationDuration", "animationEasing"]);

  var list = (0, _react.useRef)();

  var _useState = (0, _react.useState)(),
      _useState2 = _slicedToArray(_useState, 2),
      dragging = _useState2[0],
      setDragging = _useState2[1];

  var _useState3 = (0, _react.useState)(),
      _useState4 = _slicedToArray(_useState3, 2),
      willEndDragging = _useState4[0],
      setWillEndDragging = _useState4[1];

  var touchId = (0, _react.useRef)();
  var dragMoveHandler = (0, _react.useRef)();
  var draggedItemPosition = (0, _react.useRef)();
  var itemShiftsY = (0, _react.useRef)();
  var itemsOrder = (0, _react.useRef)();
  var prevItems = (0, _react.useRef)();

  if (items !== prevItems.current) {
    prevItems.current = items; // Reset items order.

    itemsOrder.current = items.map(function (item, i) {
      return i;
    });
  }

  (0, _react.useEffect)(function () {
    // Don't know why is this here.
    var onTouchMove = function onTouchMove() {};

    window.addEventListener('touchmove', onTouchMove);
    return function () {
      window.removeEventListener('touchmove', onTouchMove);
    };
  }, []);
  var onDragStart = (0, _react.useCallback)(function (node, y, touch) {
    if (dragging) {
      return;
    } // The list requires at least two items in order to be sortable.


    if (items.length === 1) {
      return;
    }

    var item = getItem(list.current, node, dragHandleDataAttribute);

    if (!item) {
      return;
    }

    var _item = _slicedToArray(item, 2),
        itemNode = _item[0],
        position = _item[1];

    setDragging({
      touch: touch,
      initialPosition: position,
      // Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`
      // because `.offsetXxx` values don't know how to work with fractional pixels.
      // Fractional pixels (for example, `0.5`) are used on "retina" screens.
      itemHeights: Array.prototype.map.call(list.current.childNodes, function (node) {
        return node.getBoundingClientRect().height;
      }),
      itemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,
      itemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,
      dragStartY: y
    });
    draggedItemPosition.current = {
      previous: position,
      "new": position,
      shiftY: 0
    };
    itemShiftsY.current = items.map(function (_) {
      return 0;
    });
  }, [dragging]);
  var onMouseDown = (0, _react.useCallback)(function (event) {
    // Left mouse button only.
    if (event.button !== 0) {
      return;
    }

    onDragStart(event.target, event.pageY);
  }, [onDragStart]);
  var onTouchStart = (0, _react.useCallback)(function (event) {
    // Single touch only.
    if (event.touches.length > 1) {
      return;
    }

    var touch = event.changedTouches[0];
    onDragStart(event.target, touch.pageY, touch.identifier);
  }, [onDragStart]);
  var onDragMove = (0, _react.useCallback)(function (event) {
    if (!dragging) {
      return;
    }

    var y;

    if (dragging.touch !== undefined) {
      for (var _iterator = event.changedTouches, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref2 = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var touch = _ref2;

        if (touch.identifier === dragging.touch) {
          y = touch.pageY;
          break;
        }
      }
    } else {
      y = event.pageY;
    }

    if (y === undefined) {
      return;
    }

    event.preventDefault();
    var movedY = y - dragging.dragStartY;
    var draggedItemOffsetTop = dragging.itemTopOffset + movedY;
    var position = getDraggedItemPosition(dragging.itemHeights, dragging.itemSpacing, draggedItemOffsetTop, dragging.initialPosition);
    var draggedItemHeight = dragging.itemHeights[dragging.initialPosition]; // Update list items' positions.

    itemShiftsY.current = items.map(function (_, j) {
      if (j < dragging.initialPosition) {
        if (j >= position) {
          return draggedItemHeight + dragging.itemSpacing;
        } else {
          return 0;
        }
      } else if (j > dragging.initialPosition) {
        if (j <= position) {
          return -1 * (draggedItemHeight + dragging.itemSpacing);
        } else {
          return 0;
        }
      } else {
        return movedY;
      }
    }); // Apply item shifts Y.

    var i = 0;

    while (i < items.length) {
      list.current.childNodes[i].style.transform = "translateY(".concat(itemShiftsY.current[i], "px)");
      i++;
    }

    draggedItemPosition.current = {
      previous: dragging.initialPosition,
      "new": position,
      shiftY: getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, position) - getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, dragging.initialPosition)
    };
  }, [dragging]);
  var onDragEnd = (0, _react.useCallback)(function () {
    setDragging();
    setWillEndDragging(true);
    var newItemsOrder = getNewItemsOrder(itemsOrder.current, draggedItemPosition.current.previous, draggedItemPosition.current["new"]);
    setTimeout(function () {
      setWillEndDragging(false);
      itemsOrder.current = newItemsOrder;
      onChange(newItemsOrder.map(function (i) {
        return items[i];
      }));
    }, animationDuration);
  }, [itemsOrder.current]);
  var onMouseUp = (0, _react.useCallback)(function (event) {
    if (event.which !== 1) {
      return;
    }

    onDragEnd();
  }, [onDragEnd]);
  var onTouchEnd = (0, _react.useCallback)(function (event) {
    for (var _iterator2 = event.changedTouches, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref3 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var touch = _ref3;

      if (touch.identifier === touchId.current) {
        onDragEnd();
        return;
      }
    }
  }, [onDragEnd]);
  (0, _react.useEffect)(function () {
    if (dragging) {
      dragMoveHandler.current = onDragMove;

      if (dragging.touch !== undefined) {
        touchId.current = dragging.touch;
        window.addEventListener('touchmove', dragMoveHandler.current, {
          passive: false
        });
        window.addEventListener('touchend', onTouchEnd);
      } else {
        window.addEventListener('mousemove', dragMoveHandler.current, {
          passive: false
        });
        window.addEventListener('mouseup', onMouseUp);
      }
    } else {
      if (touchId.current !== undefined) {
        touchId.current = undefined;
        window.removeEventListener('touchmove', dragMoveHandler.current, {
          passive: false
        });
        window.removeEventListener('touchend', onTouchEnd);
      } else {
        window.removeEventListener('mousemove', dragMoveHandler.current, {
          passive: false
        });
        window.removeEventListener('mouseup', onMouseUp);
      }

      dragMoveHandler.current = undefined;
    }
  }, [dragging]);
  (0, _react.useEffect)(function () {
    if (willEndDragging) {
      // Reset dragged item position.
      list.current.childNodes[draggedItemPosition.current.previous].style.transform = "translateY(".concat(draggedItemPosition.current.shiftY, "px)");
    }
  }, [willEndDragging]);
  return _react["default"].createElement(Component, _extends({}, rest, {
    ref: list,
    onTouchStart: onTouchStart,
    onMouseDown: onMouseDown
  }), itemsOrder.current.map(function (i, position) {
    return _react["default"].createElement(ItemComponent, _extends({}, itemComponentProps, {
      key: i,
      dragging: dragging ? true : false,
      dragged: dragging && position === draggedItemPosition.current.previous,
      style: dragging || willEndDragging ? getItemStyle(position === draggedItemPosition.current.previous, willEndDragging, itemShiftsY.current[position], animationDuration, animationEasing) : TRANSFORM_NONE
    }), items[i]);
  }));
}

SortableList.propTypes = {
  value: _propTypes["default"].arrayOf(_propTypes["default"].any).isRequired,
  onChange: _propTypes["default"].func.isRequired,
  component: _propTypes["default"].elementType.isRequired,
  itemComponent: _propTypes["default"].elementType.isRequired,
  itemComponentProps: _propTypes["default"].object,
  animationDuration: _propTypes["default"].number.isRequired,
  animationEasing: _propTypes["default"].string.isRequired
};
var TRANSFORM_NONE = {
  transform: 'none'
};

function getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {
  var style = {
    // `position: relative` is for `z-index` to work.
    position: 'relative',
    transition: "all ".concat(animationDuration, "ms ").concat(animationEasing)
  };

  if (isDragged) {
    style.zIndex = 1;

    if (!willEndDragging) {
      style.transition = undefined;
    }
  } else {
    style.transform = "translateY(".concat(shiftY, "px)");
  }

  return style;
}

var ListComponent = _react["default"].forwardRef(function (_ref4, ref) {
  var children = _ref4.children,
      rest = _objectWithoutProperties(_ref4, ["children"]);

  return _react["default"].createElement("div", _extends({
    ref: ref
  }, rest), children);
});

SortableList.defaultProps = {
  component: ListComponent,
  animationDuration: 200,
  animationEasing: 'ease-out' // Interactive elements aren't draggable.

};
var IGNORE_CLICKS_INSIDE_TAGS = ['a', 'button', 'input', 'textarea', 'select'];
/**
 * Returns the list item that has been clicked (along with its index).
 * @param {Element} list
 * @param {Element} node — The DOM Element that has been clicked.
 * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.
 * @return {any[]} [result] — An array having shape `[item, i]`.
 */

function getItem(list, node, dragHandleDataAttribute) {
  var handle;
  var childNode;

  while (node) {
    if (node === list) {
      // Clicked outside of a handle.
      if (dragHandleDataAttribute && !handle) {
        return;
      }

      if (childNode) {
        var i = 0;

        while (i < node.childNodes.length) {
          if (node.childNodes[i] === childNode) {
            return [childNode, i];
          }

          i++;
        }
      }

      break;
    }

    if (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {
      return;
    }

    if (node.dataset[dragHandleDataAttribute]) {
      handle = node;
    }

    childNode = node;
    node = node.parentElement;
  }
}

function getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {
  var scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2;
  var y = 0;
  var i = 0;
  var subtractOwnPosition = 0;

  while (i < itemHeights.length) {
    y += itemHeights[i] + itemSpacing;

    if (scanLineY <= y) {
      return i;
    }

    i++;
  }

  return itemHeights.length - 1;
}

function getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {
  var top = 0;
  var j = 0;

  while (j < position) {
    if (j === initialPosition) {
      position++;
    } else {
      top += itemHeights[j] + itemSpacing;
    }

    j++;
  }

  return top;
}

function getNewItemsOrder(itemsOrder, fromPosition, toPosition) {
  if (toPosition < fromPosition) {
    return itemsOrder.slice(0, toPosition).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition, fromPosition)).concat(itemsOrder.slice(fromPosition + 1));
  }

  if (toPosition > fromPosition) {
    return itemsOrder.slice(0, fromPosition).concat(itemsOrder.slice(fromPosition + 1, toPosition + 1)).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition + 1));
  }

  return itemsOrder.slice();
}
//# sourceMappingURL=SortableList.js.map