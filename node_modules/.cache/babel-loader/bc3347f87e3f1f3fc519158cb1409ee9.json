{"ast":null,"code":"import _classCallCheck from \"E:/Front-End-Challenges/React-Challenges/Completed Challenges/ReactTodo/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Front-End-Challenges/React-Challenges/Completed Challenges/ReactTodo/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { invariant } from '@react-dnd/invariant';\nimport { getDifferenceFromInitialOffset as _getDifferenceFromInitialOffset, getSourceClientOffset as _getSourceClientOffset } from '../utils/coords.js';\nimport { areDirty } from '../utils/dirtiness.js';\nimport { matchesType } from '../utils/matchesType.js';\nexport var DragDropMonitorImpl = /*#__PURE__*/function () {\n  function DragDropMonitorImpl(store, registry) {\n    _classCallCheck(this, DragDropMonitorImpl);\n\n    this.store = store;\n    this.registry = registry;\n  }\n\n  _createClass(DragDropMonitorImpl, [{\n    key: \"subscribeToStateChange\",\n    value: function subscribeToStateChange(listener) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var handlerIds = options.handlerIds;\n      invariant(typeof listener === 'function', 'listener must be a function.');\n      invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n      var prevStateId = this.store.getState().stateId;\n\n      var handleChange = function handleChange() {\n        var state = _this.store.getState();\n\n        var currentStateId = state.stateId;\n\n        try {\n          var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n\n          if (!canSkipListener) {\n            listener();\n          }\n        } finally {\n          prevStateId = currentStateId;\n        }\n      };\n\n      return this.store.subscribe(handleChange);\n    }\n  }, {\n    key: \"subscribeToOffsetChange\",\n    value: function subscribeToOffsetChange(listener) {\n      var _this2 = this;\n\n      invariant(typeof listener === 'function', 'listener must be a function.');\n      var previousState = this.store.getState().dragOffset;\n\n      var handleChange = function handleChange() {\n        var nextState = _this2.store.getState().dragOffset;\n\n        if (nextState === previousState) {\n          return;\n        }\n\n        previousState = nextState;\n        listener();\n      };\n\n      return this.store.subscribe(handleChange);\n    }\n  }, {\n    key: \"canDragSource\",\n    value: function canDragSource(sourceId) {\n      if (!sourceId) {\n        return false;\n      }\n\n      var source = this.registry.getSource(sourceId);\n      invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n\n      if (this.isDragging()) {\n        return false;\n      }\n\n      return source.canDrag(this, sourceId);\n    }\n  }, {\n    key: \"canDropOnTarget\",\n    value: function canDropOnTarget(targetId) {\n      // undefined on initial render\n      if (!targetId) {\n        return false;\n      }\n\n      var target = this.registry.getTarget(targetId);\n      invariant(target, \"Expected to find a valid target. targetId=\".concat(targetId));\n\n      if (!this.isDragging() || this.didDrop()) {\n        return false;\n      }\n\n      var targetType = this.registry.getTargetType(targetId);\n      var draggedItemType = this.getItemType();\n      return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n  }, {\n    key: \"isDragging\",\n    value: function isDragging() {\n      return Boolean(this.getItemType());\n    }\n  }, {\n    key: \"isDraggingSource\",\n    value: function isDraggingSource(sourceId) {\n      // undefined on initial render\n      if (!sourceId) {\n        return false;\n      }\n\n      var source = this.registry.getSource(sourceId, true);\n      invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n\n      if (!this.isDragging() || !this.isSourcePublic()) {\n        return false;\n      }\n\n      var sourceType = this.registry.getSourceType(sourceId);\n      var draggedItemType = this.getItemType();\n\n      if (sourceType !== draggedItemType) {\n        return false;\n      }\n\n      return source.isDragging(this, sourceId);\n    }\n  }, {\n    key: \"isOverTarget\",\n    value: function isOverTarget(targetId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n\n      // undefined on initial render\n      if (!targetId) {\n        return false;\n      }\n\n      var shallow = options.shallow;\n\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      var targetType = this.registry.getTargetType(targetId);\n      var draggedItemType = this.getItemType();\n\n      if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n        return false;\n      }\n\n      var targetIds = this.getTargetIds();\n\n      if (!targetIds.length) {\n        return false;\n      }\n\n      var index = targetIds.indexOf(targetId);\n\n      if (shallow) {\n        return index === targetIds.length - 1;\n      } else {\n        return index > -1;\n      }\n    }\n  }, {\n    key: \"getItemType\",\n    value: function getItemType() {\n      return this.store.getState().dragOperation.itemType;\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem() {\n      return this.store.getState().dragOperation.item;\n    }\n  }, {\n    key: \"getSourceId\",\n    value: function getSourceId() {\n      return this.store.getState().dragOperation.sourceId;\n    }\n  }, {\n    key: \"getTargetIds\",\n    value: function getTargetIds() {\n      return this.store.getState().dragOperation.targetIds;\n    }\n  }, {\n    key: \"getDropResult\",\n    value: function getDropResult() {\n      return this.store.getState().dragOperation.dropResult;\n    }\n  }, {\n    key: \"didDrop\",\n    value: function didDrop() {\n      return this.store.getState().dragOperation.didDrop;\n    }\n  }, {\n    key: \"isSourcePublic\",\n    value: function isSourcePublic() {\n      return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n  }, {\n    key: \"getInitialClientOffset\",\n    value: function getInitialClientOffset() {\n      return this.store.getState().dragOffset.initialClientOffset;\n    }\n  }, {\n    key: \"getInitialSourceClientOffset\",\n    value: function getInitialSourceClientOffset() {\n      return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n  }, {\n    key: \"getClientOffset\",\n    value: function getClientOffset() {\n      return this.store.getState().dragOffset.clientOffset;\n    }\n  }, {\n    key: \"getSourceClientOffset\",\n    value: function getSourceClientOffset() {\n      return _getSourceClientOffset(this.store.getState().dragOffset);\n    }\n  }, {\n    key: \"getDifferenceFromInitialOffset\",\n    value: function getDifferenceFromInitialOffset() {\n      return _getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n  }]);\n\n  return DragDropMonitorImpl;\n}();","map":{"version":3,"mappings":";;AAAA,SAASA,SAAT,QAA0B,sBAA1B;AAYA,SACCC,8BAA8B,IAA9BA,+BADD,EAECC,qBAAqB,IAArBA,sBAFD,QAGO,oBAHP;AAIA,SAASC,QAAT,QAAyB,uBAAzB;AACA,SAASC,WAAT,QAA4B,yBAA5B;AAEA,WAAaC,mBAAb;EAIC,6BAAmBC,KAAnB,EAAwCC,QAAxC,EAAmE;IAAA;;IAClE,KAAKD,KAAL,GAAaA,KAAb;IACA,KAAKC,QAAL,GAAgBA,QAAhB;EACA;;EAPF;IAAA;IAAA,OASC,gCACCC,QADD,EAGe;MAAA;;MAAA,IADdC,OACc,uEADuB,EACvB;MACd,IAAQC,UAAR,GAAuBD,OAAvB,CAAQC,UAAR;MACAV,SAAS,CAAC,OAAOQ,QAAP,KAAoB,UAArB,EAAiC,8BAAjC,CAATR;MACAA,SAAS,CACR,OAAOU,UAAP,KAAsB,WAAtB,IAAqCC,KAAK,CAACC,OAAND,CAAcD,UAAdC,CAD7B,EAER,0DAFQ,CAATX;MAKA,IAAIa,WAAW,GAAG,KAAKP,KAAL,CAAWQ,QAAX,GAAsBC,OAAxC;;MACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,GAAM;QAC1B,IAAMC,KAAK,GAAG,KAAI,CAACX,KAAL,CAAWQ,QAAX,EAAd;;QACA,IAAMI,cAAc,GAAGD,KAAK,CAACF,OAA7B;;QACA,IAAI;UACH,IAAMI,eAAe,GACpBD,cAAc,KAAKL,WAAnBK,IACCA,cAAc,KAAKL,WAAW,GAAG,CAAjCK,IACA,CAACf,QAAQ,CAACc,KAAK,CAACG,eAAP,EAAwBV,UAAxB,CAHX;;UAKA,IAAI,CAACS,eAAL,EAAsB;YACrBX,QAAQ;UACR;QACD,CATD,SASU;UACTK,WAAW,GAAGK,cAAdL;QACA;MACD,CAfD;;MAiBA,OAAO,KAAKP,KAAL,CAAWe,SAAX,CAAqBL,YAArB,CAAP;IACA;EAvCF;IAAA;IAAA,OAyCC,iCAA+BR,QAA/B,EAAgE;MAAA;;MAC/DR,SAAS,CAAC,OAAOQ,QAAP,KAAoB,UAArB,EAAiC,8BAAjC,CAATR;MAEA,IAAIsB,aAAa,GAAG,KAAKhB,KAAL,CAAWQ,QAAX,GAAsBS,UAA1C;;MACA,IAAMP,YAAY,GAAG,SAAfA,YAAe,GAAM;QAC1B,IAAMQ,SAAS,GAAG,MAAI,CAAClB,KAAL,CAAWQ,QAAX,GAAsBS,UAAxC;;QACA,IAAIC,SAAS,KAAKF,aAAlB,EAAiC;UAChC;QACA;;QAEDA,aAAa,GAAGE,SAAhBF;QACAd,QAAQ;MACR,CARD;;MAUA,OAAO,KAAKF,KAAL,CAAWe,SAAX,CAAqBL,YAArB,CAAP;IACA;EAxDF;IAAA;IAAA,OA0DC,uBAAqBS,QAArB,EAA4D;MAC3D,IAAI,CAACA,QAAL,EAAe;QACd,OAAO,KAAP;MACA;;MACD,IAAMC,MAAM,GAAG,KAAKnB,QAAL,CAAcoB,SAAd,CAAwBF,QAAxB,CAAf;MACAzB,SAAS,CAAC0B,MAAD,sDAAsDD,QAAtD,EAATzB;;MAEA,IAAI,KAAK4B,UAAL,EAAJ,EAAuB;QACtB,OAAO,KAAP;MACA;;MAED,OAAOF,MAAM,CAACG,OAAPH,CAAe,IAAfA,EAAqBD,QAArBC,CAAP;IACA;EAtEF;IAAA;IAAA,OAwEC,yBAAuBI,QAAvB,EAA8D;MAC7D;MACA,IAAI,CAACA,QAAL,EAAe;QACd,OAAO,KAAP;MACA;;MACD,IAAMC,MAAM,GAAG,KAAKxB,QAAL,CAAcyB,SAAd,CAAwBF,QAAxB,CAAf;MACA9B,SAAS,CAAC+B,MAAD,sDAAsDD,QAAtD,EAAT9B;;MAEA,IAAI,CAAC,KAAK4B,UAAL,EAAD,IAAsB,KAAKK,OAAL,EAA1B,EAA0C;QACzC,OAAO,KAAP;MACA;;MAED,IAAMC,UAAU,GAAG,KAAK3B,QAAL,CAAc4B,aAAd,CAA4BL,QAA5B,CAAnB;MACA,IAAMM,eAAe,GAAG,KAAKC,WAAL,EAAxB;MACA,OACCjC,WAAW,CAAC8B,UAAD,EAAaE,eAAb,CAAXhC,IAA4C2B,MAAM,CAACO,OAAPP,CAAe,IAAfA,EAAqBD,QAArBC,CAD7C;IAGA;EAzFF;IAAA;IAAA,OA2FC,sBAA6B;MAC5B,OAAOQ,OAAO,CAAC,KAAKF,WAAL,EAAD,CAAd;IACA;EA7FF;IAAA;IAAA,OA+FC,0BAAwBZ,QAAxB,EAA+D;MAC9D;MACA,IAAI,CAACA,QAAL,EAAe;QACd,OAAO,KAAP;MACA;;MACD,IAAMC,MAAM,GAAG,KAAKnB,QAAL,CAAcoB,SAAd,CAAwBF,QAAxB,EAAkC,IAAlC,CAAf;MACAzB,SAAS,CAAC0B,MAAD,sDAAsDD,QAAtD,EAATzB;;MAEA,IAAI,CAAC,KAAK4B,UAAL,EAAD,IAAsB,CAAC,KAAKY,cAAL,EAA3B,EAAkD;QACjD,OAAO,KAAP;MACA;;MAED,IAAMC,UAAU,GAAG,KAAKlC,QAAL,CAAcmC,aAAd,CAA4BjB,QAA5B,CAAnB;MACA,IAAMW,eAAe,GAAG,KAAKC,WAAL,EAAxB;;MACA,IAAII,UAAU,KAAKL,eAAnB,EAAoC;QACnC,OAAO,KAAP;MACA;;MAED,OAAOV,MAAM,CAACE,UAAPF,CAAkB,IAAlBA,EAAwBD,QAAxBC,CAAP;IACA;EAlHF;IAAA;IAAA,OAoHC,sBACCI,QADD,EAGW;MAAA,IADVrB,OACU,uEADA;QAAEkC,OAAO,EAAE;MAAX,CACA;;MACV;MACA,IAAI,CAACb,QAAL,EAAe;QACd,OAAO,KAAP;MACA;;MAED,IAAQa,OAAR,GAAoBlC,OAApB,CAAQkC,OAAR;;MACA,IAAI,CAAC,KAAKf,UAAL,EAAL,EAAwB;QACvB,OAAO,KAAP;MACA;;MAED,IAAMM,UAAU,GAAG,KAAK3B,QAAL,CAAc4B,aAAd,CAA4BL,QAA5B,CAAnB;MACA,IAAMM,eAAe,GAAG,KAAKC,WAAL,EAAxB;;MACA,IAAID,eAAe,IAAI,CAAChC,WAAW,CAAC8B,UAAD,EAAaE,eAAb,CAAnC,EAAkE;QACjE,OAAO,KAAP;MACA;;MAED,IAAMQ,SAAS,GAAG,KAAKC,YAAL,EAAlB;;MACA,IAAI,CAACD,SAAS,CAACE,MAAf,EAAuB;QACtB,OAAO,KAAP;MACA;;MAED,IAAMC,KAAK,GAAGH,SAAS,CAACI,OAAVJ,CAAkBd,QAAlBc,CAAd;;MACA,IAAID,OAAJ,EAAa;QACZ,OAAOI,KAAK,KAAKH,SAAS,CAACE,MAAVF,GAAmB,CAApC;MACA,CAFD,MAEO;QACN,OAAOG,KAAK,GAAG,CAAC,CAAhB;MACA;IACD;EAnJF;IAAA;IAAA,OAqJC,uBAAiC;MAChC,OAAO,KAAKzC,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCC,QAA3C;IACA;EAvJF;IAAA;IAAA,OAyJC,mBAAsB;MACrB,OAAO,KAAK5C,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCE,IAA3C;IACA;EA3JF;IAAA;IAAA,OA6JC,uBAAoC;MACnC,OAAO,KAAK7C,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCxB,QAA3C;IACA;EA/JF;IAAA;IAAA,OAiKC,wBAAgC;MAC/B,OAAO,KAAKnB,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCL,SAA3C;IACA;EAnKF;IAAA;IAAA,OAqKC,yBAA4B;MAC3B,OAAO,KAAKtC,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCG,UAA3C;IACA;EAvKF;IAAA;IAAA,OAyKC,mBAA0B;MACzB,OAAO,KAAK9C,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoChB,OAA3C;IACA;EA3KF;IAAA;IAAA,OA6KC,0BAAiC;MAChC,OAAOM,OAAO,CAAC,KAAKjC,KAAL,CAAWQ,QAAX,GAAsBmC,aAAtB,CAAoCT,cAArC,CAAd;IACA;EA/KF;IAAA;IAAA,OAiLC,kCAAgD;MAC/C,OAAO,KAAKlC,KAAL,CAAWQ,QAAX,GAAsBS,UAAtB,CAAiC8B,mBAAxC;IACA;EAnLF;IAAA;IAAA,OAqLC,wCAAsD;MACrD,OAAO,KAAK/C,KAAL,CAAWQ,QAAX,GAAsBS,UAAtB,CAAiC+B,yBAAxC;IACA;EAvLF;IAAA;IAAA,OAyLC,2BAAyC;MACxC,OAAO,KAAKhD,KAAL,CAAWQ,QAAX,GAAsBS,UAAtB,CAAiCgC,YAAxC;IACA;EA3LF;IAAA;IAAA,OA6LC,iCAA+C;MAC9C,OAAOrD,sBAAqB,CAAC,KAAKI,KAAL,CAAWQ,QAAX,GAAsBS,UAAvB,CAA5B;IACA;EA/LF;IAAA;IAAA,OAiMC,0CAAwD;MACvD,OAAOtB,+BAA8B,CAAC,KAAKK,KAAL,CAAWQ,QAAX,GAAsBS,UAAvB,CAArC;IACA;EAnMF;;EAAA;AAAA","names":["invariant","getDifferenceFromInitialOffset","getSourceClientOffset","areDirty","matchesType","DragDropMonitorImpl","store","registry","listener","options","handlerIds","Array","isArray","prevStateId","getState","stateId","handleChange","state","currentStateId","canSkipListener","dirtyHandlerIds","subscribe","previousState","dragOffset","nextState","sourceId","source","getSource","isDragging","canDrag","targetId","target","getTarget","didDrop","targetType","getTargetType","draggedItemType","getItemType","canDrop","Boolean","isSourcePublic","sourceType","getSourceType","shallow","targetIds","getTargetIds","length","index","indexOf","dragOperation","itemType","item","dropResult","initialClientOffset","initialSourceClientOffset","clientOffset"],"sources":["E:\\Front-End-Challenges\\React-Challenges\\Completed Challenges\\ReactTodo\\node_modules\\dnd-core\\src\\classes\\DragDropMonitorImpl.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type { Store } from 'redux'\n\nimport type {\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n} from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport {\n\tgetDifferenceFromInitialOffset,\n\tgetSourceClientOffset,\n} from '../utils/coords.js'\nimport { areDirty } from '../utils/dirtiness.js'\nimport { matchesType } from '../utils/matchesType.js'\n\nexport class DragDropMonitorImpl implements DragDropMonitor {\n\tprivate store: Store<State>\n\tpublic readonly registry: HandlerRegistry\n\n\tpublic constructor(store: Store<State>, registry: HandlerRegistry) {\n\t\tthis.store = store\n\t\tthis.registry = registry\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions: { handlerIds?: string[] } = {},\n\t): Unsubscribe {\n\t\tconst { handlerIds } = options\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\t\tinvariant(\n\t\t\ttypeof handlerIds === 'undefined' || Array.isArray(handlerIds),\n\t\t\t'handlerIds, when specified, must be an array of strings.',\n\t\t)\n\n\t\tlet prevStateId = this.store.getState().stateId\n\t\tconst handleChange = () => {\n\t\t\tconst state = this.store.getState()\n\t\t\tconst currentStateId = state.stateId\n\t\t\ttry {\n\t\t\t\tconst canSkipListener =\n\t\t\t\t\tcurrentStateId === prevStateId ||\n\t\t\t\t\t(currentStateId === prevStateId + 1 &&\n\t\t\t\t\t\t!areDirty(state.dirtyHandlerIds, handlerIds))\n\n\t\t\t\tif (!canSkipListener) {\n\t\t\t\t\tlistener()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tprevStateId = currentStateId\n\t\t\t}\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic subscribeToOffsetChange(listener: Listener): Unsubscribe {\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\n\t\tlet previousState = this.store.getState().dragOffset\n\t\tconst handleChange = () => {\n\t\t\tconst nextState = this.store.getState().dragOffset\n\t\t\tif (nextState === previousState) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreviousState = nextState\n\t\t\tlistener()\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic canDragSource(sourceId: string | undefined): boolean {\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.canDrag(this, sourceId)\n\t}\n\n\tpublic canDropOnTarget(targetId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\t\tconst target = this.registry.getTarget(targetId)\n\t\tinvariant(target, `Expected to find a valid target. targetId=${targetId}`)\n\n\t\tif (!this.isDragging() || this.didDrop()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\treturn (\n\t\t\tmatchesType(targetType, draggedItemType) && target.canDrop(this, targetId)\n\t\t)\n\t}\n\n\tpublic isDragging(): boolean {\n\t\treturn Boolean(this.getItemType())\n\t}\n\n\tpublic isDraggingSource(sourceId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId, true)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (!this.isDragging() || !this.isSourcePublic()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst sourceType = this.registry.getSourceType(sourceId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (sourceType !== draggedItemType) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.isDragging(this, sourceId)\n\t}\n\n\tpublic isOverTarget(\n\t\ttargetId: string | undefined,\n\t\toptions = { shallow: false },\n\t): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst { shallow } = options\n\t\tif (!this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (draggedItemType && !matchesType(targetType, draggedItemType)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetIds = this.getTargetIds()\n\t\tif (!targetIds.length) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst index = targetIds.indexOf(targetId)\n\t\tif (shallow) {\n\t\t\treturn index === targetIds.length - 1\n\t\t} else {\n\t\t\treturn index > -1\n\t\t}\n\t}\n\n\tpublic getItemType(): Identifier {\n\t\treturn this.store.getState().dragOperation.itemType as Identifier\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.store.getState().dragOperation.item\n\t}\n\n\tpublic getSourceId(): string | null {\n\t\treturn this.store.getState().dragOperation.sourceId\n\t}\n\n\tpublic getTargetIds(): string[] {\n\t\treturn this.store.getState().dragOperation.targetIds\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.store.getState().dragOperation.dropResult\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.store.getState().dragOperation.didDrop\n\t}\n\n\tpublic isSourcePublic(): boolean {\n\t\treturn Boolean(this.store.getState().dragOperation.isSourcePublic)\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialClientOffset\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialSourceClientOffset\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.clientOffset\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn getSourceClientOffset(this.store.getState().dragOffset)\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn getDifferenceFromInitialOffset(this.store.getState().dragOffset)\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}