{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = SortableList;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\r\n * Demo:\r\n * https://codepen.io/catamphetamine/pen/qBWxEQX\r\n *\r\n * `itemComponent` receives properties:\r\n * `dragging: boolean` — Is `true` when some item is being dragged.\r\n * `dragged: boolean` — Is `true` when this item is being dragged.\r\n * `style: object` — The `style` that must be set on the item root element.\r\n */\n\n\nfunction SortableList(_ref) {\n  var items = _ref.value,\n      onChange = _ref.onChange,\n      Component = _ref.component,\n      ItemComponent = _ref.itemComponent,\n      itemComponentProps = _ref.itemComponentProps,\n      dragHandleDataAttribute = _ref.dragHandleDataAttribute,\n      animationDuration = _ref.animationDuration,\n      animationEasing = _ref.animationEasing,\n      rest = _objectWithoutProperties(_ref, [\"value\", \"onChange\", \"component\", \"itemComponent\", \"itemComponentProps\", \"dragHandleDataAttribute\", \"animationDuration\", \"animationEasing\"]);\n\n  var list = (0, _react.useRef)();\n\n  var _useState = (0, _react.useState)(),\n      _useState2 = _slicedToArray(_useState, 2),\n      dragging = _useState2[0],\n      setDragging = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      willEndDragging = _useState4[0],\n      setWillEndDragging = _useState4[1];\n\n  var touchId = (0, _react.useRef)();\n  var dragMoveHandler = (0, _react.useRef)();\n  var draggedItemPosition = (0, _react.useRef)();\n  var itemShiftsY = (0, _react.useRef)();\n  var itemsOrder = (0, _react.useRef)();\n  var prevItems = (0, _react.useRef)();\n\n  if (items !== prevItems.current) {\n    prevItems.current = items; // Reset items order.\n\n    itemsOrder.current = items.map(function (item, i) {\n      return i;\n    });\n  }\n\n  (0, _react.useEffect)(function () {\n    // Don't know why is this here.\n    var onTouchMove = function onTouchMove() {};\n\n    window.addEventListener('touchmove', onTouchMove);\n    return function () {\n      window.removeEventListener('touchmove', onTouchMove);\n    };\n  }, []);\n  var onDragStart = (0, _react.useCallback)(function (node, y, touch) {\n    if (dragging) {\n      return;\n    } // The list requires at least two items in order to be sortable.\n\n\n    if (items.length === 1) {\n      return;\n    }\n\n    var item = getItem(list.current, node, dragHandleDataAttribute);\n\n    if (!item) {\n      return;\n    }\n\n    var _item = _slicedToArray(item, 2),\n        itemNode = _item[0],\n        position = _item[1];\n\n    setDragging({\n      touch: touch,\n      initialPosition: position,\n      // Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\n      // because `.offsetXxx` values don't know how to work with fractional pixels.\n      // Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\n      itemHeights: Array.prototype.map.call(list.current.childNodes, function (node) {\n        return node.getBoundingClientRect().height;\n      }),\n      itemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,\n      itemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,\n      dragStartY: y\n    });\n    draggedItemPosition.current = {\n      previous: position,\n      \"new\": position,\n      shiftY: 0\n    };\n    itemShiftsY.current = items.map(function (_) {\n      return 0;\n    });\n  }, [dragging]);\n  var onMouseDown = (0, _react.useCallback)(function (event) {\n    // Left mouse button only.\n    if (event.button !== 0) {\n      return;\n    }\n\n    onDragStart(event.target, event.pageY);\n  }, [onDragStart]);\n  var onTouchStart = (0, _react.useCallback)(function (event) {\n    // Single touch only.\n    if (event.touches.length > 1) {\n      return;\n    }\n\n    var touch = event.changedTouches[0];\n    onDragStart(event.target, touch.pageY, touch.identifier);\n  }, [onDragStart]);\n  var onDragMove = (0, _react.useCallback)(function (event) {\n    if (!dragging) {\n      return;\n    }\n\n    var y;\n\n    if (dragging.touch !== undefined) {\n      for (var _iterator = event.changedTouches, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray) {\n          if (_i2 >= _iterator.length) break;\n          _ref2 = _iterator[_i2++];\n        } else {\n          _i2 = _iterator.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var touch = _ref2;\n\n        if (touch.identifier === dragging.touch) {\n          y = touch.pageY;\n          break;\n        }\n      }\n    } else {\n      y = event.pageY;\n    }\n\n    if (y === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n    var movedY = y - dragging.dragStartY;\n    var draggedItemOffsetTop = dragging.itemTopOffset + movedY;\n    var position = getDraggedItemPosition(dragging.itemHeights, dragging.itemSpacing, draggedItemOffsetTop, dragging.initialPosition);\n    var draggedItemHeight = dragging.itemHeights[dragging.initialPosition]; // Update list items' positions.\n\n    itemShiftsY.current = items.map(function (_, j) {\n      if (j < dragging.initialPosition) {\n        if (j >= position) {\n          return draggedItemHeight + dragging.itemSpacing;\n        } else {\n          return 0;\n        }\n      } else if (j > dragging.initialPosition) {\n        if (j <= position) {\n          return -1 * (draggedItemHeight + dragging.itemSpacing);\n        } else {\n          return 0;\n        }\n      } else {\n        return movedY;\n      }\n    }); // Apply item shifts Y.\n\n    var i = 0;\n\n    while (i < items.length) {\n      list.current.childNodes[i].style.transform = \"translateY(\".concat(itemShiftsY.current[i], \"px)\");\n      i++;\n    }\n\n    draggedItemPosition.current = {\n      previous: dragging.initialPosition,\n      \"new\": position,\n      shiftY: getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, position) - getDraggedItemPositionY(dragging.itemHeights, dragging.itemSpacing, dragging.initialPosition, dragging.initialPosition)\n    };\n  }, [dragging]);\n  var onDragEnd = (0, _react.useCallback)(function () {\n    setDragging();\n    setWillEndDragging(true);\n    var newItemsOrder = getNewItemsOrder(itemsOrder.current, draggedItemPosition.current.previous, draggedItemPosition.current[\"new\"]);\n    setTimeout(function () {\n      setWillEndDragging(false);\n      itemsOrder.current = newItemsOrder;\n      onChange(newItemsOrder.map(function (i) {\n        return items[i];\n      }));\n    }, animationDuration);\n  }, [itemsOrder.current]);\n  var onMouseUp = (0, _react.useCallback)(function (event) {\n    if (event.which !== 1) {\n      return;\n    }\n\n    onDragEnd();\n  }, [onDragEnd]);\n  var onTouchEnd = (0, _react.useCallback)(function (event) {\n    for (var _iterator2 = event.changedTouches, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i3 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i3++];\n      } else {\n        _i3 = _iterator2.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var touch = _ref3;\n\n      if (touch.identifier === touchId.current) {\n        onDragEnd();\n        return;\n      }\n    }\n  }, [onDragEnd]);\n  (0, _react.useEffect)(function () {\n    if (dragging) {\n      dragMoveHandler.current = onDragMove;\n\n      if (dragging.touch !== undefined) {\n        touchId.current = dragging.touch;\n        window.addEventListener('touchmove', dragMoveHandler.current, {\n          passive: false\n        });\n        window.addEventListener('touchend', onTouchEnd);\n      } else {\n        window.addEventListener('mousemove', dragMoveHandler.current, {\n          passive: false\n        });\n        window.addEventListener('mouseup', onMouseUp);\n      }\n    } else {\n      if (touchId.current !== undefined) {\n        touchId.current = undefined;\n        window.removeEventListener('touchmove', dragMoveHandler.current, {\n          passive: false\n        });\n        window.removeEventListener('touchend', onTouchEnd);\n      } else {\n        window.removeEventListener('mousemove', dragMoveHandler.current, {\n          passive: false\n        });\n        window.removeEventListener('mouseup', onMouseUp);\n      }\n\n      dragMoveHandler.current = undefined;\n    }\n  }, [dragging]);\n  (0, _react.useEffect)(function () {\n    if (willEndDragging) {\n      // Reset dragged item position.\n      list.current.childNodes[draggedItemPosition.current.previous].style.transform = \"translateY(\".concat(draggedItemPosition.current.shiftY, \"px)\");\n    }\n  }, [willEndDragging]);\n  return _react[\"default\"].createElement(Component, _extends({}, rest, {\n    ref: list,\n    onTouchStart: onTouchStart,\n    onMouseDown: onMouseDown\n  }), itemsOrder.current.map(function (i, position) {\n    return _react[\"default\"].createElement(ItemComponent, _extends({}, itemComponentProps, {\n      key: i,\n      dragging: dragging ? true : false,\n      dragged: dragging && position === draggedItemPosition.current.previous,\n      style: dragging || willEndDragging ? getItemStyle(position === draggedItemPosition.current.previous, willEndDragging, itemShiftsY.current[position], animationDuration, animationEasing) : TRANSFORM_NONE\n    }), items[i]);\n  }));\n}\n\nSortableList.propTypes = {\n  value: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].any).isRequired,\n  onChange: _propTypes[\"default\"].func.isRequired,\n  component: _propTypes[\"default\"].elementType.isRequired,\n  itemComponent: _propTypes[\"default\"].elementType.isRequired,\n  itemComponentProps: _propTypes[\"default\"].object,\n  animationDuration: _propTypes[\"default\"].number.isRequired,\n  animationEasing: _propTypes[\"default\"].string.isRequired\n};\nvar TRANSFORM_NONE = {\n  transform: 'none'\n};\n\nfunction getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {\n  var style = {\n    // `position: relative` is for `z-index` to work.\n    position: 'relative',\n    transition: \"all \".concat(animationDuration, \"ms \").concat(animationEasing)\n  };\n\n  if (isDragged) {\n    style.zIndex = 1;\n\n    if (!willEndDragging) {\n      style.transition = undefined;\n    }\n  } else {\n    style.transform = \"translateY(\".concat(shiftY, \"px)\");\n  }\n\n  return style;\n}\n\nvar ListComponent = _react[\"default\"].forwardRef(function (_ref4, ref) {\n  var children = _ref4.children,\n      rest = _objectWithoutProperties(_ref4, [\"children\"]);\n\n  return _react[\"default\"].createElement(\"div\", _extends({\n    ref: ref\n  }, rest), children);\n});\n\nSortableList.defaultProps = {\n  component: ListComponent,\n  animationDuration: 200,\n  animationEasing: 'ease-out' // Interactive elements aren't draggable.\n\n};\nvar IGNORE_CLICKS_INSIDE_TAGS = ['a', 'button', 'input', 'textarea', 'select'];\n/**\r\n * Returns the list item that has been clicked (along with its index).\r\n * @param {Element} list\r\n * @param {Element} node — The DOM Element that has been clicked.\r\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\r\n * @return {any[]} [result] — An array having shape `[item, i]`.\r\n */\n\nfunction getItem(list, node, dragHandleDataAttribute) {\n  var handle;\n  var childNode;\n\n  while (node) {\n    if (node === list) {\n      // Clicked outside of a handle.\n      if (dragHandleDataAttribute && !handle) {\n        return;\n      }\n\n      if (childNode) {\n        var i = 0;\n\n        while (i < node.childNodes.length) {\n          if (node.childNodes[i] === childNode) {\n            return [childNode, i];\n          }\n\n          i++;\n        }\n      }\n\n      break;\n    }\n\n    if (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {\n      return;\n    }\n\n    if (node.dataset[dragHandleDataAttribute]) {\n      handle = node;\n    }\n\n    childNode = node;\n    node = node.parentElement;\n  }\n}\n\nfunction getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {\n  var scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2;\n  var y = 0;\n  var i = 0;\n  var subtractOwnPosition = 0;\n\n  while (i < itemHeights.length) {\n    y += itemHeights[i] + itemSpacing;\n\n    if (scanLineY <= y) {\n      return i;\n    }\n\n    i++;\n  }\n\n  return itemHeights.length - 1;\n}\n\nfunction getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {\n  var top = 0;\n  var j = 0;\n\n  while (j < position) {\n    if (j === initialPosition) {\n      position++;\n    } else {\n      top += itemHeights[j] + itemSpacing;\n    }\n\n    j++;\n  }\n\n  return top;\n}\n\nfunction getNewItemsOrder(itemsOrder, fromPosition, toPosition) {\n  if (toPosition < fromPosition) {\n    return itemsOrder.slice(0, toPosition).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition, fromPosition)).concat(itemsOrder.slice(fromPosition + 1));\n  }\n\n  if (toPosition > fromPosition) {\n    return itemsOrder.slice(0, fromPosition).concat(itemsOrder.slice(fromPosition + 1, toPosition + 1)).concat(itemsOrder[fromPosition]).concat(itemsOrder.slice(toPosition + 1));\n  }\n\n  return itemsOrder.slice();\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;AASe,SAASA,YAAT,OAUZ;AAAA,MATKC,KASL,QATFC,KASE;AAAA,MARFC,QAQE,QARFA,QAQE;AAAA,MAPSC,SAOT,QAPFC,SAOE;AAAA,MANaC,aAMb,QANFC,aAME;AAAA,MALFC,kBAKE,QALFA,kBAKE;AAAA,MAJFC,uBAIE,QAJFA,uBAIE;AAAA,MAHFC,iBAGE,QAHFA,iBAGE;AAAA,MAFFC,eAEE,QAFFA,eAEE;AAAA,MADCC,IACD;;AACF,MAAMC,IAAI,GAAG,oBAAb;;AADE,kBAE8B,sBAF9B;AAAA;AAAA,MAEKC,QAFL;AAAA,MAEeC,WAFf;;AAAA,mBAG4C,sBAH5C;AAAA;AAAA,MAGKC,eAHL;AAAA,MAGsBC,kBAHtB;;AAIF,MAAMC,OAAO,GAAG,oBAAhB;AACA,MAAMC,eAAe,GAAG,oBAAxB;AACA,MAAMC,mBAAmB,GAAG,oBAA5B;AACA,MAAMC,WAAW,GAAG,oBAApB;AAEA,MAAMC,UAAU,GAAG,oBAAnB;AACA,MAAMC,SAAS,GAAG,oBAAlB;;AACA,MAAItB,KAAK,KAAKsB,SAAS,CAACC,OAAxB,EAAiC;AAChCD,aAAS,CAACC,OAAVD,GAAoBtB,KAApBsB,CADgC,CAEhC;;AACAD,cAAU,CAACE,OAAXF,GAAqBrB,KAAK,CAACwB,GAANxB,CAAU,UAACyB,IAAD,EAAOC,CAAP;AAAA,aAAaA,CAAb;AAAV,MAArBL;AACA;;AAED,wBAAU,YAAM;AACf;AACA,QAAMM,WAAW,GAAG,SAAdA,WAAc,GAAM,CAA1B;;AACAC,UAAM,CAACC,gBAAPD,CAAwB,WAAxBA,EAAqCD,WAArCC;AACA,WAAO,YAAM;AACZA,YAAM,CAACE,mBAAPF,CAA2B,WAA3BA,EAAwCD,WAAxCC;AADD;AAJD,KAOG,EAPH;AASA,MAAMG,WAAW,GAAG,wBAAY,UAACC,IAAD,EAAOC,CAAP,EAAUC,KAAV,EAAoB;AACnD,QAAIrB,QAAJ,EAAc;AACb;AAFkD,MAInD;;;AACA,QAAIb,KAAK,CAACmC,MAANnC,KAAiB,CAArB,EAAwB;AACvB;AACA;;AACD,QAAMyB,IAAI,GAAGW,OAAO,CAACxB,IAAI,CAACW,OAAN,EAAeS,IAAf,EAAqBxB,uBAArB,CAApB;;AACA,QAAI,CAACiB,IAAL,EAAW;AACV;AACA;;AAXkD,+BAYtBA,IAZsB;AAAA,QAY5CY,QAZ4C;AAAA,QAYlCC,QAZkC;;AAanDxB,eAAW,CAAC;AACXoB,WAAK,EAALA,KADW;AAEXK,qBAAe,EAAED,QAFN;AAGX;AACA;AACA;AACAE,iBAAW,EAAEC,KAAK,CAACC,SAAND,CAAgBjB,GAAhBiB,CAAoBE,IAApBF,CAAyB7B,IAAI,CAACW,OAALX,CAAagC,UAAtCH,EAAkD,gBAAI;AAAA,eAAIT,IAAI,CAACa,qBAALb,GAA6Bc,MAAjC;AAAtD,QANF;AAOXC,iBAAW,EAAEnC,IAAI,CAACW,OAALX,CAAagC,UAAbhC,CAAwB,CAAxBA,EAA2BiC,qBAA3BjC,GAAmDoC,GAAnDpC,GAAyDA,IAAI,CAACW,OAALX,CAAagC,UAAbhC,CAAwB,CAAxBA,EAA2BiC,qBAA3BjC,GAAmDqC,MAP9G;AAQXC,mBAAa,EAAEb,QAAQ,CAACQ,qBAATR,GAAiCW,GAAjCX,GAAuCzB,IAAI,CAACW,OAALX,CAAagC,UAAbhC,CAAwB,CAAxBA,EAA2BiC,qBAA3BjC,GAAmDoC,GAR9F;AASXG,gBAAU,EAAElB;AATD,KAAD,CAAXnB;AAWAK,uBAAmB,CAACI,OAApBJ,GAA8B;AAC7BiC,cAAQ,EAAEd,QADmB;AAE7B,aAAKA,QAFwB;AAG7Be,YAAM,EAAE;AAHqB,KAA9BlC;AAKAC,eAAW,CAACG,OAAZH,GAAsBpB,KAAK,CAACwB,GAANxB,CAAU,aAAC;AAAA,aAAI,CAAJ;AAAX,MAAtBoB;AA7BmB,KA8BjB,CAACP,QAAD,CA9BiB,CAApB;AAgCA,MAAMyC,WAAW,GAAG,wBAAY,UAACC,KAAD,EAAW;AAC1C;AACA,QAAIA,KAAK,CAACC,MAAND,KAAiB,CAArB,EAAwB;AACvB;AACA;;AACDxB,eAAW,CAACwB,KAAK,CAACE,MAAP,EAAeF,KAAK,CAACG,KAArB,CAAX3B;AALmB,KAMjB,CAACA,WAAD,CANiB,CAApB;AAQA,MAAM4B,YAAY,GAAG,wBAAY,UAACJ,KAAD,EAAW;AAC3C;AACA,QAAIA,KAAK,CAACK,OAANL,CAAcpB,MAAdoB,GAAuB,CAA3B,EAA8B;AAC7B;AACA;;AACD,QAAMrB,KAAK,GAAGqB,KAAK,CAACM,cAANN,CAAqB,CAArBA,CAAd;AACAxB,eAAW,CAACwB,KAAK,CAACE,MAAP,EAAevB,KAAK,CAACwB,KAArB,EAA4BxB,KAAK,CAAC4B,UAAlC,CAAX/B;AANoB,KAOlB,CAACA,WAAD,CAPkB,CAArB;AASA,MAAMgC,UAAU,GAAG,wBAAY,UAACR,KAAD,EAAW;AACzC,QAAI,CAAC1C,QAAL,EAAe;AACd;AACA;;AAED,QAAIoB,CAAJ;;AACA,QAAIpB,QAAQ,CAACqB,KAATrB,KAAmBmD,SAAvB,EAAkC;AACjC,2BAAoBT,KAAK,CAACM,cAA1B,mHAA0C;AAAA;;AAAA;AAAA;AAAAI;AAAA;AAAAC;AAAA;AAAAD;AAAA;;AAAA,YAA/B/B,KAA+B;;AACzC,YAAIA,KAAK,CAAC4B,UAAN5B,KAAqBrB,QAAQ,CAACqB,KAAlC,EAAyC;AACxCD,WAAC,GAAGC,KAAK,CAACwB,KAAVzB;AACA;AACA;AACD;AANF,WAOO;AACNA,OAAC,GAAGsB,KAAK,CAACG,KAAVzB;AACA;;AAED,QAAIA,CAAC,KAAK+B,SAAV,EAAqB;AACpB;AACA;;AAEDT,SAAK,CAACY,cAANZ;AAEA,QAAMa,MAAM,GAAGnC,CAAC,GAAGpB,QAAQ,CAACsC,UAA5B;AACA,QAAMkB,oBAAoB,GAAGxD,QAAQ,CAACqC,aAATrC,GAAyBuD,MAAtD;AAEA,QAAM9B,QAAQ,GAAGgC,sBAAsB,CACtCzD,QAAQ,CAAC2B,WAD6B,EAEtC3B,QAAQ,CAACkC,WAF6B,EAGtCsB,oBAHsC,EAItCxD,QAAQ,CAAC0B,eAJ6B,CAAvC;AAOA,QAAMgC,iBAAiB,GAAG1D,QAAQ,CAAC2B,WAAT3B,CAAqBA,QAAQ,CAAC0B,eAA9B1B,CAA1B,CAjCyC,CAmCzC;;AACAO,eAAW,CAACG,OAAZH,GAAsBpB,KAAK,CAACwB,GAANxB,CAAU,UAACwE,CAAD,EAAIC,CAAJ,EAAU;AACzC,UAAIA,CAAC,GAAG5D,QAAQ,CAAC0B,eAAjB,EAAkC;AACjC,YAAIkC,CAAC,IAAInC,QAAT,EAAmB;AAClB,iBAAOiC,iBAAiB,GAAG1D,QAAQ,CAACkC,WAApC;AADD,eAEO;AACN,iBAAO,CAAP;AACA;AALF,aAMO,IAAI0B,CAAC,GAAG5D,QAAQ,CAAC0B,eAAjB,EAAkC;AACxC,YAAIkC,CAAC,IAAInC,QAAT,EAAmB;AAClB,iBAAO,CAAC,CAAD,IAAMiC,iBAAiB,GAAG1D,QAAQ,CAACkC,WAAnC,CAAP;AADD,eAEO;AACN,iBAAO,CAAP;AACA;AALK,aAMA;AACN,eAAOqB,MAAP;AACA;AAfoB,MAAtBhD,CApCyC,CAsDzC;;AACA,QAAIM,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAG1B,KAAK,CAACmC,MAAjB,EAAyB;AACxBvB,UAAI,CAACW,OAALX,CAAagC,UAAbhC,CAAwBc,CAAxBd,EAA2B8D,KAA3B9D,CAAiC+D,SAAjC/D,wBAA2DQ,WAAW,CAACG,OAAZH,CAAoBM,CAApBN,CAA3D;AACAM,OAAC;AACD;;AAEDP,uBAAmB,CAACI,OAApBJ,GAA8B;AAC7BiC,cAAQ,EAAEvC,QAAQ,CAAC0B,eADU;AAE7B,aAAKD,QAFwB;AAG7Be,YAAM,EAAEuB,uBAAuB,CAC9B/D,QAAQ,CAAC2B,WADqB,EAE9B3B,QAAQ,CAACkC,WAFqB,EAG9BlC,QAAQ,CAAC0B,eAHqB,EAI9BD,QAJ8B,CAAvBsC,GAKJA,uBAAuB,CAC1B/D,QAAQ,CAAC2B,WADiB,EAE1B3B,QAAQ,CAACkC,WAFiB,EAG1BlC,QAAQ,CAAC0B,eAHiB,EAI1B1B,QAAQ,CAAC0B,eAJiB;AARE,KAA9BpB;AA7DkB,KA4EhB,CAACN,QAAD,CA5EgB,CAAnB;AA8EA,MAAMgE,SAAS,GAAG,wBAAY,YAAM;AACnC/D,eAAW;AACXE,sBAAkB,CAAC,IAAD,CAAlBA;AACA,QAAM8D,aAAa,GAAGC,gBAAgB,CACrC1D,UAAU,CAACE,OAD0B,EAErCJ,mBAAmB,CAACI,OAApBJ,CAA4BiC,QAFS,EAGrCjC,mBAAmB,CAACI,OAApBJ,OAHqC,CAAtC;AAKA6D,cAAU,CAAC,YAAM;AAChBhE,wBAAkB,CAAC,KAAD,CAAlBA;AACAK,gBAAU,CAACE,OAAXF,GAAqByD,aAArBzD;AACAnB,cAAQ,CAAC4E,aAAa,CAACtD,GAAdsD,CAAkB,aAAC;AAAA,eAAI9E,KAAK,CAAC0B,CAAD,CAAT;AAAnB,QAAD,CAARxB;AAHS,OAIPO,iBAJO,CAAVuE;AARiB,KAaf,CAAC3D,UAAU,CAACE,OAAZ,CAbe,CAAlB;AAeA,MAAM0D,SAAS,GAAG,wBAAY,UAAC1B,KAAD,EAAW;AACxC,QAAIA,KAAK,CAAC2B,KAAN3B,KAAgB,CAApB,EAAuB;AACtB;AACA;;AACDsB,aAAS;AAJQ,KAKf,CAACA,SAAD,CALe,CAAlB;AAOA,MAAMM,UAAU,GAAG,wBAAY,UAAC5B,KAAD,EAAW;AACzC,0BAAoBA,KAAK,CAACM,cAA1B,yHAA0C;AAAA;;AAAA;AAAA;AAAAuB;AAAA;AAAAC;AAAA;AAAAD;AAAA;;AAAA,UAA/BlD,KAA+B;;AACzC,UAAIA,KAAK,CAAC4B,UAAN5B,KAAqBjB,OAAO,CAACM,OAAjC,EAA0C;AACzCsD,iBAAS;AACT;AACA;AACD;AANiB,KAOhB,CAACA,SAAD,CAPgB,CAAnB;AASA,wBAAU,YAAM;AACf,QAAIhE,QAAJ,EAAc;AACbK,qBAAe,CAACK,OAAhBL,GAA0B6C,UAA1B7C;;AACA,UAAIL,QAAQ,CAACqB,KAATrB,KAAmBmD,SAAvB,EAAkC;AACjC/C,eAAO,CAACM,OAARN,GAAkBJ,QAAQ,CAACqB,KAA3BjB;AACAW,cAAM,CAACC,gBAAPD,CAAwB,WAAxBA,EAAqCV,eAAe,CAACK,OAArDK,EAA8D;AAAE0D,iBAAO,EAAE;AAAX,SAA9D1D;AACAA,cAAM,CAACC,gBAAPD,CAAwB,UAAxBA,EAAoCuD,UAApCvD;AAHD,aAIO;AACNA,cAAM,CAACC,gBAAPD,CAAwB,WAAxBA,EAAqCV,eAAe,CAACK,OAArDK,EAA8D;AAAE0D,iBAAO,EAAE;AAAX,SAA9D1D;AACAA,cAAM,CAACC,gBAAPD,CAAwB,SAAxBA,EAAmCqD,SAAnCrD;AACA;AATF,WAUO;AACN,UAAIX,OAAO,CAACM,OAARN,KAAoB+C,SAAxB,EAAmC;AAClC/C,eAAO,CAACM,OAARN,GAAkB+C,SAAlB/C;AACAW,cAAM,CAACE,mBAAPF,CAA2B,WAA3BA,EAAwCV,eAAe,CAACK,OAAxDK,EAAiE;AAAE0D,iBAAO,EAAE;AAAX,SAAjE1D;AACAA,cAAM,CAACE,mBAAPF,CAA2B,UAA3BA,EAAuCuD,UAAvCvD;AAHD,aAIO;AACNA,cAAM,CAACE,mBAAPF,CAA2B,WAA3BA,EAAwCV,eAAe,CAACK,OAAxDK,EAAiE;AAAE0D,iBAAO,EAAE;AAAX,SAAjE1D;AACAA,cAAM,CAACE,mBAAPF,CAA2B,SAA3BA,EAAsCqD,SAAtCrD;AACA;;AACDV,qBAAe,CAACK,OAAhBL,GAA0B8C,SAA1B9C;AACA;AArBF,KAsBG,CAACL,QAAD,CAtBH;AAwBA,wBAAU,YAAM;AACf,QAAIE,eAAJ,EAAqB;AACpB;AACAH,UAAI,CAACW,OAALX,CAAagC,UAAbhC,CAAwBO,mBAAmB,CAACI,OAApBJ,CAA4BiC,QAApDxC,EAA8D8D,KAA9D9D,CAAoE+D,SAApE/D,wBACCO,mBAAmB,CAACI,OAApBJ,CAA4BkC,MAD7B;AAGA;AANF,KAOG,CAACtC,eAAD,CAPH;AASA,SACCwE,gCAACpF,SAAD,eACKQ,IADL;AAEC6E,OAAG,EAAE5E,IAFN;AAGC+C,gBAAY,EAAEA,YAHf;AAICL,eAAW,EAAEA;AAJd,MAKEjC,UAAU,CAACE,OAAXF,CAAmBG,GAAnBH,CAAuB,UAACK,CAAD,EAAIY,QAAJ;AAAA,WACvBiD,gCAAClF,aAAD,eACKE,kBADL;AAECkF,SAAG,EAAE/D,CAFN;AAGCb,cAAQ,EAAEA,QAAQ,GAAG,IAAH,GAAU,KAH7B;AAIC6E,aAAO,EAAE7E,QAAQ,IAAIyB,QAAQ,KAAKnB,mBAAmB,CAACI,OAApBJ,CAA4BiC,QAJ/D;AAKCsB,WAAK,EAAG7D,QAAQ,IAAIE,eAAZF,GAA+B8E,YAAY,CAClDrD,QAAQ,KAAKnB,mBAAmB,CAACI,OAApBJ,CAA4BiC,QADS,EAElDrC,eAFkD,EAGlDK,WAAW,CAACG,OAAZH,CAAoBkB,QAApBlB,CAHkD,EAIlDX,iBAJkD,EAKlDC,eALkD,CAA3CG,GAMJ+E;AAXL,QAYE5F,KAAK,CAAC0B,CAAD,CAZP,CADuB;AAAvB,IALF,CADD;AAwBA;;AAED3B,YAAY,CAAC8F,SAAb9F,GAAyB;AACxBE,OAAK,EAAE6F,sBAAUC,OAAVD,CAAkBA,sBAAUE,GAA5BF,EAAiCG,UADhB;AAExB/F,UAAQ,EAAE4F,sBAAUI,IAAVJ,CAAeG,UAFD;AAGxB7F,WAAS,EAAE0F,sBAAUK,WAAVL,CAAsBG,UAHT;AAIxB3F,eAAa,EAAEwF,sBAAUK,WAAVL,CAAsBG,UAJb;AAKxB1F,oBAAkB,EAAEuF,sBAAUM,MALN;AAMxB3F,mBAAiB,EAAEqF,sBAAUO,MAAVP,CAAiBG,UANZ;AAOxBvF,iBAAe,EAAEoF,sBAAUQ,MAAVR,CAAiBG;AAPV,CAAzBlG;AAUA,IAAM6F,cAAc,GAAG;AAAEjB,WAAS,EAAE;AAAb,CAAvB;;AAEA,SAASgB,YAAT,CAAsBY,SAAtB,EAAiCxF,eAAjC,EAAkDsC,MAAlD,EAA0D5C,iBAA1D,EAA6EC,eAA7E,EAA8F;AAC7F,MAAMgE,KAAK,GAAG;AACb;AACApC,YAAQ,EAAE,UAFG;AAGbkE,cAAU,gBAAS/F,iBAAT,gBAAgCC,eAAhC;AAHG,GAAd;;AAKA,MAAI6F,SAAJ,EAAe;AACd7B,SAAK,CAAC+B,MAAN/B,GAAe,CAAfA;;AACA,QAAI,CAAC3D,eAAL,EAAsB;AACrB2D,WAAK,CAAC8B,UAAN9B,GAAmBV,SAAnBU;AACA;AAJF,SAKO;AACNA,SAAK,CAACC,SAAND,wBAAgCrB,MAAhC;AACA;;AACD,SAAOqB,KAAP;AACA;;AAED,IAAMgC,aAAa,GAAGC,kBAAMC,UAAND,CAAiB,iBAAwBnB,GAAxB;AAAA,MAAGqB,QAAH,SAAGA,QAAH;AAAA,MAAgBlG,IAAhB;;AAAA,SACtC4E;AAAKC,OAAG,EAAEA;AAAV,KAAmB7E,IAAnB,GACEkG,QADF,CADsC;AAAjB,EAAtB;;AAMA9G,YAAY,CAAC+G,YAAb/G,GAA4B;AAC3BK,WAAS,EAAEsG,aADgB;AAE3BjG,mBAAiB,EAAE,GAFQ;AAG3BC,iBAAe,EAAE,UAHU,CAM5B;;AAN4B,CAA5BX;AAOA,IAAMgH,yBAAyB,GAAG,CACjC,GADiC,EAEjC,QAFiC,EAGjC,OAHiC,EAIjC,UAJiC,EAKjC,QALiC,CAAlC;AAQA;;;;;;;;AAOA,SAAS3E,OAAT,CAAiBxB,IAAjB,EAAuBoB,IAAvB,EAA6BxB,uBAA7B,EAAsD;AACrD,MAAIwG,MAAJ;AACA,MAAIC,SAAJ;;AACA,SAAOjF,IAAP,EAAa;AACZ,QAAIA,IAAI,KAAKpB,IAAb,EAAmB;AAClB;AACA,UAAIJ,uBAAuB,IAAI,CAACwG,MAAhC,EAAwC;AACvC;AACA;;AACD,UAAIC,SAAJ,EAAe;AACd,YAAIvF,CAAC,GAAG,CAAR;;AACA,eAAOA,CAAC,GAAGM,IAAI,CAACY,UAALZ,CAAgBG,MAA3B,EAAmC;AAClC,cAAIH,IAAI,CAACY,UAALZ,CAAgBN,CAAhBM,MAAuBiF,SAA3B,EAAsC;AACrC,mBAAO,CAACA,SAAD,EAAYvF,CAAZ,CAAP;AACA;;AACDA,WAAC;AACD;AACD;;AACD;AACA;;AACD,QAAIqF,yBAAyB,CAACG,OAA1BH,CAAkC/E,IAAI,CAACmF,OAALnF,CAAaoF,WAAbpF,EAAlC+E,KAAiE,CAArE,EAAwE;AACvE;AACA;;AACD,QAAI/E,IAAI,CAACqF,OAALrF,CAAaxB,uBAAbwB,CAAJ,EAA2C;AAC1CgF,YAAM,GAAGhF,IAATgF;AACA;;AACDC,aAAS,GAAGjF,IAAZiF;AACAjF,QAAI,GAAGA,IAAI,CAACsF,aAAZtF;AACA;AACD;;AAED,SAASsC,sBAAT,CAAgC9B,WAAhC,EAA6CO,WAA7C,EAA0DsB,oBAA1D,EAAgF9B,eAAhF,EAAiG;AAChG,MAAMgF,SAAS,GAAGlD,oBAAoB,GAAG7B,WAAW,CAACD,eAAD,CAAXC,GAA+B,CAAtD6B,GAA0DtB,WAAW,GAAG,CAA1F;AACA,MAAId,CAAC,GAAG,CAAR;AACA,MAAIP,CAAC,GAAG,CAAR;AACA,MAAI8F,mBAAmB,GAAG,CAA1B;;AACA,SAAO9F,CAAC,GAAGc,WAAW,CAACL,MAAvB,EAA+B;AAC9BF,KAAC,IAAIO,WAAW,CAACd,CAAD,CAAXc,GAAiBO,WAAtBd;;AACA,QAAIsF,SAAS,IAAItF,CAAjB,EAAoB;AACnB,aAAOP,CAAP;AACA;;AACDA,KAAC;AACD;;AACD,SAAOc,WAAW,CAACL,MAAZK,GAAqB,CAA5B;AACA;;AAED,SAASoC,uBAAT,CAAiCpC,WAAjC,EAA8CO,WAA9C,EAA2DR,eAA3D,EAA4ED,QAA5E,EAAsF;AACrF,MAAIU,GAAG,GAAG,CAAV;AACA,MAAIyB,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGnC,QAAX,EAAqB;AACpB,QAAImC,CAAC,KAAKlC,eAAV,EAA2B;AAC1BD,cAAQ;AADT,WAEO;AACNU,SAAG,IAAIR,WAAW,CAACiC,CAAD,CAAXjC,GAAiBO,WAAxBC;AACA;;AACDyB,KAAC;AACD;;AACD,SAAOzB,GAAP;AACA;;AAED,SAAS+B,gBAAT,CAA0B1D,UAA1B,EAAsCoG,YAAtC,EAAoDC,UAApD,EAAgE;AAC/D,MAAIA,UAAU,GAAGD,YAAjB,EAA+B;AAC9B,WAAOpG,UAAU,CAACsG,KAAXtG,CAAiB,CAAjBA,EAAoBqG,UAApBrG,EACLuG,MADKvG,CACEA,UAAU,CAACoG,YAAD,CADZpG,EAELuG,MAFKvG,CAEEA,UAAU,CAACsG,KAAXtG,CAAiBqG,UAAjBrG,EAA6BoG,YAA7BpG,CAFFA,EAGLuG,MAHKvG,CAGEA,UAAU,CAACsG,KAAXtG,CAAiBoG,YAAY,GAAG,CAAhCpG,CAHFA,CAAP;AAIA;;AACD,MAAIqG,UAAU,GAAGD,YAAjB,EAA+B;AAC9B,WAAOpG,UAAU,CAACsG,KAAXtG,CAAiB,CAAjBA,EAAoBoG,YAApBpG,EACLuG,MADKvG,CACEA,UAAU,CAACsG,KAAXtG,CAAiBoG,YAAY,GAAG,CAAhCpG,EAAmCqG,UAAU,GAAG,CAAhDrG,CADFA,EAELuG,MAFKvG,CAEEA,UAAU,CAACoG,YAAD,CAFZpG,EAGLuG,MAHKvG,CAGEA,UAAU,CAACsG,KAAXtG,CAAiBqG,UAAU,GAAG,CAA9BrG,CAHFA,CAAP;AAIA;;AACD,SAAOA,UAAU,CAACsG,KAAXtG,EAAP;AACA","names":["SortableList","items","value","onChange","Component","component","ItemComponent","itemComponent","itemComponentProps","dragHandleDataAttribute","animationDuration","animationEasing","rest","list","dragging","setDragging","willEndDragging","setWillEndDragging","touchId","dragMoveHandler","draggedItemPosition","itemShiftsY","itemsOrder","prevItems","current","map","item","i","onTouchMove","window","addEventListener","removeEventListener","onDragStart","node","y","touch","length","getItem","itemNode","position","initialPosition","itemHeights","Array","prototype","call","childNodes","getBoundingClientRect","height","itemSpacing","top","bottom","itemTopOffset","dragStartY","previous","shiftY","onMouseDown","event","button","target","pageY","onTouchStart","touches","changedTouches","identifier","onDragMove","undefined","_ref2","_i2","preventDefault","movedY","draggedItemOffsetTop","getDraggedItemPosition","draggedItemHeight","_","j","style","transform","getDraggedItemPositionY","onDragEnd","newItemsOrder","getNewItemsOrder","setTimeout","onMouseUp","which","onTouchEnd","_ref3","_i3","passive","_react","ref","key","dragged","getItemStyle","TRANSFORM_NONE","propTypes","PropTypes","arrayOf","any","isRequired","func","elementType","object","number","string","isDragged","transition","zIndex","ListComponent","React","forwardRef","children","defaultProps","IGNORE_CLICKS_INSIDE_TAGS","handle","childNode","indexOf","tagName","toLowerCase","dataset","parentElement","scanLineY","subtractOwnPosition","fromPosition","toPosition","slice","concat"],"sources":["E:\\Front-End-Challenges\\React-Challenges\\ReactTodo\\node_modules\\react-sortable-dnd-list\\source\\SortableList.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n/**\r\n * Demo:\r\n * https://codepen.io/catamphetamine/pen/qBWxEQX\r\n *\r\n * `itemComponent` receives properties:\r\n * `dragging: boolean` — Is `true` when some item is being dragged.\r\n * `dragged: boolean` — Is `true` when this item is being dragged.\r\n * `style: object` — The `style` that must be set on the item root element.\r\n */\r\nexport default function SortableList({\r\n\tvalue: items,\r\n\tonChange,\r\n\tcomponent: Component,\r\n\titemComponent: ItemComponent,\r\n\titemComponentProps,\r\n\tdragHandleDataAttribute,\r\n\tanimationDuration,\r\n\tanimationEasing,\r\n\t...rest\r\n}) {\r\n\tconst list = useRef()\r\n\tconst [dragging, setDragging] = useState()\r\n\tconst [willEndDragging, setWillEndDragging] = useState()\r\n\tconst touchId = useRef()\r\n\tconst dragMoveHandler = useRef()\r\n\tconst draggedItemPosition = useRef()\r\n\tconst itemShiftsY = useRef()\r\n\r\n\tconst itemsOrder = useRef()\r\n\tconst prevItems = useRef()\r\n\tif (items !== prevItems.current) {\r\n\t\tprevItems.current = items\r\n\t\t// Reset items order.\r\n\t\titemsOrder.current = items.map((item, i) => i)\r\n\t}\r\n\r\n\tuseEffect(() => {\r\n\t\t// Don't know why is this here.\r\n\t\tconst onTouchMove = () => {}\r\n\t\twindow.addEventListener('touchmove', onTouchMove)\r\n\t\treturn () => {\r\n\t\t\twindow.removeEventListener('touchmove', onTouchMove)\r\n\t\t}\r\n\t}, [])\r\n\r\n\tconst onDragStart = useCallback((node, y, touch) => {\r\n\t\tif (dragging) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// The list requires at least two items in order to be sortable.\r\n\t\tif (items.length === 1) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst item = getItem(list.current, node, dragHandleDataAttribute)\r\n\t\tif (!item) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst [itemNode, position] = item\r\n\t\tsetDragging({\r\n\t\t\ttouch,\r\n\t\t\tinitialPosition: position,\r\n\t\t\t// Using `.getBoundingClientRect()` instead of `.offsetHeight`/`.offsetTop`\r\n\t\t\t// because `.offsetXxx` values don't know how to work with fractional pixels.\r\n\t\t\t// Fractional pixels (for example, `0.5`) are used on \"retina\" screens.\r\n\t\t\titemHeights: Array.prototype.map.call(list.current.childNodes, node => node.getBoundingClientRect().height),\r\n\t\t\titemSpacing: list.current.childNodes[1].getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().bottom,\r\n\t\t\titemTopOffset: itemNode.getBoundingClientRect().top - list.current.childNodes[0].getBoundingClientRect().top,\r\n\t\t\tdragStartY: y\r\n\t\t})\r\n\t\tdraggedItemPosition.current = {\r\n\t\t\tprevious: position,\r\n\t\t\tnew: position,\r\n\t\t\tshiftY: 0\r\n\t\t}\r\n\t\titemShiftsY.current = items.map(_ => 0)\r\n\t}, [dragging])\r\n\r\n\tconst onMouseDown = useCallback((event) => {\r\n\t\t// Left mouse button only.\r\n\t\tif (event.button !== 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tonDragStart(event.target, event.pageY)\r\n\t}, [onDragStart])\r\n\r\n\tconst onTouchStart = useCallback((event) => {\r\n\t\t// Single touch only.\r\n\t\tif (event.touches.length > 1) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst touch = event.changedTouches[0]\r\n\t\tonDragStart(event.target, touch.pageY, touch.identifier)\r\n\t}, [onDragStart])\r\n\r\n\tconst onDragMove = useCallback((event) => {\r\n\t\tif (!dragging) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet y\r\n\t\tif (dragging.touch !== undefined) {\r\n\t\t\tfor (const touch of event.changedTouches) {\r\n\t\t\t\tif (touch.identifier === dragging.touch) {\r\n\t\t\t\t\ty = touch.pageY\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ty = event.pageY\r\n\t\t}\r\n\r\n\t\tif (y === undefined) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tevent.preventDefault()\r\n\r\n\t\tconst movedY = y - dragging.dragStartY\r\n\t\tconst draggedItemOffsetTop = dragging.itemTopOffset + movedY\r\n\r\n\t\tconst position = getDraggedItemPosition(\r\n\t\t\tdragging.itemHeights,\r\n\t\t\tdragging.itemSpacing,\r\n\t\t\tdraggedItemOffsetTop,\r\n\t\t\tdragging.initialPosition\r\n\t\t)\r\n\r\n\t\tconst draggedItemHeight = dragging.itemHeights[dragging.initialPosition]\r\n\r\n\t\t// Update list items' positions.\r\n\t\titemShiftsY.current = items.map((_, j) => {\r\n\t\t\tif (j < dragging.initialPosition) {\r\n\t\t\t\tif (j >= position) {\r\n\t\t\t\t\treturn draggedItemHeight + dragging.itemSpacing\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0\r\n\t\t\t\t}\r\n\t\t\t} else if (j > dragging.initialPosition) {\r\n\t\t\t\tif (j <= position) {\r\n\t\t\t\t\treturn -1 * (draggedItemHeight + dragging.itemSpacing)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn movedY\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\t// Apply item shifts Y.\r\n\t\tlet i = 0\r\n\t\twhile (i < items.length) {\r\n\t\t\tlist.current.childNodes[i].style.transform = `translateY(${itemShiftsY.current[i]}px)`\r\n\t\t\ti++\r\n\t\t}\r\n\r\n\t\tdraggedItemPosition.current = {\r\n\t\t\tprevious: dragging.initialPosition,\r\n\t\t\tnew: position,\r\n\t\t\tshiftY: getDraggedItemPositionY(\r\n\t\t\t\tdragging.itemHeights,\r\n\t\t\t\tdragging.itemSpacing,\r\n\t\t\t\tdragging.initialPosition,\r\n\t\t\t\tposition\r\n\t\t\t) - getDraggedItemPositionY(\r\n\t\t\t\tdragging.itemHeights,\r\n\t\t\t\tdragging.itemSpacing,\r\n\t\t\t\tdragging.initialPosition,\r\n\t\t\t\tdragging.initialPosition\r\n\t\t\t)\r\n\t\t}\r\n\t}, [dragging])\r\n\r\n\tconst onDragEnd = useCallback(() => {\r\n\t\tsetDragging()\r\n\t\tsetWillEndDragging(true)\r\n\t\tconst newItemsOrder = getNewItemsOrder(\r\n\t\t\titemsOrder.current,\r\n\t\t\tdraggedItemPosition.current.previous,\r\n\t\t\tdraggedItemPosition.current.new\r\n\t\t)\r\n\t\tsetTimeout(() => {\r\n\t\t\tsetWillEndDragging(false)\r\n\t\t\titemsOrder.current = newItemsOrder\r\n\t\t\tonChange(newItemsOrder.map(i => items[i]))\r\n\t\t}, animationDuration)\r\n\t}, [itemsOrder.current])\r\n\r\n\tconst onMouseUp = useCallback((event) => {\r\n\t\tif (event.which !== 1) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tonDragEnd()\r\n\t}, [onDragEnd])\r\n\r\n\tconst onTouchEnd = useCallback((event) => {\r\n\t\tfor (const touch of event.changedTouches) {\r\n\t\t\tif (touch.identifier === touchId.current) {\r\n\t\t\t\tonDragEnd()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}, [onDragEnd])\r\n\r\n\tuseEffect(() => {\r\n\t\tif (dragging) {\r\n\t\t\tdragMoveHandler.current = onDragMove\r\n\t\t\tif (dragging.touch !== undefined) {\r\n\t\t\t\ttouchId.current = dragging.touch\r\n\t\t\t\twindow.addEventListener('touchmove', dragMoveHandler.current, { passive: false })\r\n\t\t\t\twindow.addEventListener('touchend', onTouchEnd)\r\n\t\t\t} else {\r\n\t\t\t\twindow.addEventListener('mousemove', dragMoveHandler.current, { passive: false })\r\n\t\t\t\twindow.addEventListener('mouseup', onMouseUp)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (touchId.current !== undefined) {\r\n\t\t\t\ttouchId.current = undefined\r\n\t\t\t\twindow.removeEventListener('touchmove', dragMoveHandler.current, { passive: false })\r\n\t\t\t\twindow.removeEventListener('touchend', onTouchEnd)\r\n\t\t\t} else {\r\n\t\t\t\twindow.removeEventListener('mousemove', dragMoveHandler.current, { passive: false })\r\n\t\t\t\twindow.removeEventListener('mouseup', onMouseUp)\r\n\t\t\t}\r\n\t\t\tdragMoveHandler.current = undefined\r\n\t\t}\r\n\t}, [dragging])\r\n\r\n\tuseEffect(() => {\r\n\t\tif (willEndDragging) {\r\n\t\t\t// Reset dragged item position.\r\n\t\t\tlist.current.childNodes[draggedItemPosition.current.previous].style.transform = `translateY(${\r\n\t\t\t\tdraggedItemPosition.current.shiftY\r\n\t\t\t}px)`\r\n\t\t}\r\n\t}, [willEndDragging])\r\n\r\n\treturn (\r\n\t\t<Component\r\n\t\t\t{...rest}\r\n\t\t\tref={list}\r\n\t\t\tonTouchStart={onTouchStart}\r\n\t\t\tonMouseDown={onMouseDown}>\r\n\t\t\t{itemsOrder.current.map((i, position) => (\r\n\t\t\t\t<ItemComponent\r\n\t\t\t\t\t{...itemComponentProps}\r\n\t\t\t\t\tkey={i}\r\n\t\t\t\t\tdragging={dragging ? true : false}\r\n\t\t\t\t\tdragged={dragging && position === draggedItemPosition.current.previous}\r\n\t\t\t\t\tstyle={(dragging || willEndDragging) ? getItemStyle(\r\n\t\t\t\t\t\tposition === draggedItemPosition.current.previous,\r\n\t\t\t\t\t\twillEndDragging,\r\n\t\t\t\t\t\titemShiftsY.current[position],\r\n\t\t\t\t\t\tanimationDuration,\r\n\t\t\t\t\t\tanimationEasing\r\n\t\t\t\t\t) : TRANSFORM_NONE}>\r\n\t\t\t\t\t{items[i]}\r\n\t\t\t\t</ItemComponent>\r\n\t\t\t))}\r\n\t\t</Component>\r\n\t)\r\n}\r\n\r\nSortableList.propTypes = {\r\n\tvalue: PropTypes.arrayOf(PropTypes.any).isRequired,\r\n\tonChange: PropTypes.func.isRequired,\r\n\tcomponent: PropTypes.elementType.isRequired,\r\n\titemComponent: PropTypes.elementType.isRequired,\r\n\titemComponentProps: PropTypes.object,\r\n\tanimationDuration: PropTypes.number.isRequired,\r\n\tanimationEasing: PropTypes.string.isRequired\r\n}\r\n\r\nconst TRANSFORM_NONE = { transform: 'none' }\r\n\r\nfunction getItemStyle(isDragged, willEndDragging, shiftY, animationDuration, animationEasing) {\r\n\tconst style = {\r\n\t\t// `position: relative` is for `z-index` to work.\r\n\t\tposition: 'relative',\r\n\t\ttransition: `all ${animationDuration}ms ${animationEasing}`\r\n\t}\r\n\tif (isDragged) {\r\n\t\tstyle.zIndex = 1\r\n\t\tif (!willEndDragging) {\r\n\t\t\tstyle.transition = undefined\r\n\t\t}\r\n\t} else {\r\n\t\tstyle.transform = `translateY(${shiftY}px)`\r\n\t}\r\n\treturn style\r\n}\r\n\r\nconst ListComponent = React.forwardRef(({ children, ...rest }, ref) => (\r\n\t<div ref={ref} {...rest}>\r\n\t\t{children}\r\n\t</div>\r\n))\r\n\r\nSortableList.defaultProps = {\r\n\tcomponent: ListComponent,\r\n\tanimationDuration: 200,\r\n\tanimationEasing: 'ease-out'\r\n}\r\n\r\n// Interactive elements aren't draggable.\r\nconst IGNORE_CLICKS_INSIDE_TAGS = [\r\n\t'a',\r\n\t'button',\r\n\t'input',\r\n\t'textarea',\r\n\t'select'\r\n]\r\n\r\n/**\r\n * Returns the list item that has been clicked (along with its index).\r\n * @param {Element} list\r\n * @param {Element} node — The DOM Element that has been clicked.\r\n * @param {string} [dragHandleDataAttribute] — Drag handle data attribute.\r\n * @return {any[]} [result] — An array having shape `[item, i]`.\r\n */\r\nfunction getItem(list, node, dragHandleDataAttribute) {\r\n\tlet handle\r\n\tlet childNode\r\n\twhile (node) {\r\n\t\tif (node === list) {\r\n\t\t\t// Clicked outside of a handle.\r\n\t\t\tif (dragHandleDataAttribute && !handle) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (childNode) {\r\n\t\t\t\tlet i = 0\r\n\t\t\t\twhile (i < node.childNodes.length) {\r\n\t\t\t\t\tif (node.childNodes[i] === childNode) {\r\n\t\t\t\t\t\treturn [childNode, i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (IGNORE_CLICKS_INSIDE_TAGS.indexOf(node.tagName.toLowerCase()) >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (node.dataset[dragHandleDataAttribute]) {\r\n\t\t\thandle = node\r\n\t\t}\r\n\t\tchildNode = node\r\n\t\tnode = node.parentElement\r\n\t}\r\n}\r\n\r\nfunction getDraggedItemPosition(itemHeights, itemSpacing, draggedItemOffsetTop, initialPosition) {\r\n\tconst scanLineY = draggedItemOffsetTop + itemHeights[initialPosition] / 2 + itemSpacing / 2\r\n\tlet y = 0\r\n\tlet i = 0\r\n\tlet subtractOwnPosition = 0\r\n\twhile (i < itemHeights.length) {\r\n\t\ty += itemHeights[i] + itemSpacing\r\n\t\tif (scanLineY <= y) {\r\n\t\t\treturn i\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn itemHeights.length - 1\r\n}\r\n\r\nfunction getDraggedItemPositionY(itemHeights, itemSpacing, initialPosition, position) {\r\n\tlet top = 0\r\n\tlet j = 0\r\n\twhile (j < position) {\r\n\t\tif (j === initialPosition) {\r\n\t\t\tposition++\r\n\t\t} else {\r\n\t\t\ttop += itemHeights[j] + itemSpacing\r\n\t\t}\r\n\t\tj++\r\n\t}\r\n\treturn top\r\n}\r\n\r\nfunction getNewItemsOrder(itemsOrder, fromPosition, toPosition) {\r\n\tif (toPosition < fromPosition) {\r\n\t\treturn itemsOrder.slice(0, toPosition)\r\n\t\t\t.concat(itemsOrder[fromPosition])\r\n\t\t\t.concat(itemsOrder.slice(toPosition, fromPosition))\r\n\t\t\t.concat(itemsOrder.slice(fromPosition + 1))\r\n\t}\r\n\tif (toPosition > fromPosition) {\r\n\t\treturn itemsOrder.slice(0, fromPosition)\r\n\t\t\t.concat(itemsOrder.slice(fromPosition + 1, toPosition + 1))\r\n\t\t\t.concat(itemsOrder[fromPosition])\r\n\t\t\t.concat(itemsOrder.slice(toPosition + 1))\r\n\t}\r\n\treturn itemsOrder.slice()\r\n}"]},"metadata":{},"sourceType":"script"}