{"ast":null,"code":"var _eventNames;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces';\nimport { eventShouldStartDrag, eventShouldEndDrag, isTouchEvent } from './utils/predicates';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets';\nimport { distance, inAngleRanges } from './utils/math';\nimport { supportsPassive } from './utils/supportsPassive';\nimport { OptionsReader } from './OptionsReader';\nvar eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}), _defineProperty(_eventNames, ListenerType.touch, {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}), _defineProperty(_eventNames, ListenerType.keyboard, {\n  keydown: 'keydown'\n}), _eventNames);\nexport var TouchBackendImpl = /*#__PURE__*/function () {\n  function TouchBackendImpl(manager, context, options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchBackendImpl);\n\n    this.getSourceClientOffset = function (sourceId) {\n      var element = _this.sourceNodes.get(sourceId);\n\n      return element && getNodeClientOffset(element);\n    };\n\n    this.handleTopMoveStartCapture = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      _this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      var clientOffset = getEventClientOffset(e);\n\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          _this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n\n        _this._mouseClientOffset = clientOffset;\n      }\n\n      _this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = function (_evt, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = function (e) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n\n      var moveStartSourceIds = _this.moveStartSourceIds,\n          dragOverTargetIds = _this.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = getEventClientOffset(e, _this.lastTargetTouchFallback);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!_this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n\n      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());\n\n      _this.installSourceNodeRemovalObserver(sourceNode);\n\n      _this.actions.publishDragSource();\n\n      if (e.cancelable) e.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes.get(key);\n      }).filter(function (e) {\n        return !!e;\n      }); // Get the a ordered list of nodes that are touched by\n\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      var elementsAtPointExtended = [];\n\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        var currentNode = elementsAtPoint[nodeId];\n        elementsAtPointExtended.push(currentNode);\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        return _this._getDropTargetId(node);\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      }); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          var targetNode = _this.targetNodes.get(targetId);\n\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n     *\n     * visible for testing\n     */\n\n\n    this._getDropTargetId = function (node) {\n      var keys = _this.targetNodes.keys();\n\n      var next = keys.next();\n\n      while (next.done === false) {\n        var targetId = next.value;\n\n        if (node === _this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n\n      return undefined;\n    };\n\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n      _this.lastTargetTouchFallback = undefined;\n\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      if (e.cancelable) e.preventDefault();\n      _this._mouseClientOffset = {};\n\n      _this.uninstallSourceNodeRemovalObserver();\n\n      _this.actions.drop();\n\n      _this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n\n        _this.uninstallSourceNodeRemovalObserver();\n\n        _this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n  /**\n   * Generate profiling statistics for the HTML5Backend.\n   */\n\n\n  _createClass(TouchBackendImpl, [{\n    key: \"profile\",\n    value: function profile() {\n      var _this$dragOverTargetI;\n\n      return {\n        sourceNodes: this.sourceNodes.size,\n        sourcePreviewNodes: this.sourcePreviewNodes.size,\n        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n        targetNodes: this.targetNodes.size,\n        dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0\n      };\n    } // public for test\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      if (!this.window) {\n        return;\n      }\n\n      invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n      TouchBackendImpl.isSetUp = true;\n      this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n      this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.addEventListener(this.window, 'move', this.handleTopMove);\n      this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (!this.window) {\n        return;\n      }\n\n      TouchBackendImpl.isSetUp = false;\n      this._mouseClientOffset = {};\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n      this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.removeEventListener(this.window, 'move', this.handleTopMove);\n      this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n\n      this.uninstallSourceNodeRemovalObserver();\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.addEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.removeEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"connectDragSource\",\n    value: function connectDragSource(sourceId, node) {\n      var _this2 = this;\n\n      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n      this.sourceNodes.set(sourceId, node);\n      this.addEventListener(node, 'start', handleMoveStart);\n      return function () {\n        _this2.sourceNodes.delete(sourceId);\n\n        _this2.removeEventListener(node, 'start', handleMoveStart);\n      };\n    }\n  }, {\n    key: \"connectDragPreview\",\n    value: function connectDragPreview(sourceId, node, options) {\n      var _this3 = this;\n\n      this.sourcePreviewNodeOptions.set(sourceId, options);\n      this.sourcePreviewNodes.set(sourceId, node);\n      return function () {\n        _this3.sourcePreviewNodes.delete(sourceId);\n\n        _this3.sourcePreviewNodeOptions.delete(sourceId);\n      };\n    }\n  }, {\n    key: \"connectDropTarget\",\n    value: function connectDropTarget(targetId, node) {\n      var _this4 = this;\n\n      if (!this.document) {\n        return function () {\n          /* noop */\n        };\n      }\n\n      var handleMove = function handleMove(e) {\n        if (!_this4.document || !_this4.monitor.isDragging()) {\n          return;\n        }\n\n        var coords;\n        /**\n         * Grab the coordinates for the current mouse/touch position\n         */\n\n        switch (e.type) {\n          case eventNames.mouse.move:\n            coords = {\n              x: e.clientX,\n              y: e.clientY\n            };\n            break;\n\n          case eventNames.touch.move:\n            coords = {\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY\n            };\n            break;\n        }\n        /**\n         * Use the coordinates to grab the element the drag ended on.\n         * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n         */\n\n\n        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : undefined;\n        var childMatch = droppedOn && node.contains(droppedOn);\n\n        if (droppedOn === node || childMatch) {\n          return _this4.handleMove(e, targetId);\n        }\n      };\n      /**\n       * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n       */\n\n\n      this.addEventListener(this.document.body, 'move', handleMove);\n      this.targetNodes.set(targetId, node);\n      return function () {\n        if (_this4.document) {\n          _this4.targetNodes.delete(targetId);\n\n          _this4.removeEventListener(_this4.document.body, 'move', handleMove);\n        }\n      };\n    }\n  }, {\n    key: \"getTopMoveStartHandler\",\n    value: function getTopMoveStartHandler() {\n      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n        return this.handleTopMoveStart;\n      }\n\n      return this.handleTopMoveStartDelay;\n    }\n  }, {\n    key: \"installSourceNodeRemovalObserver\",\n    value: function installSourceNodeRemovalObserver(node) {\n      var _this5 = this;\n\n      this.uninstallSourceNodeRemovalObserver();\n      this.draggedSourceNode = node;\n      this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n        if (node && !node.parentElement) {\n          _this5.resurrectSourceNode();\n\n          _this5.uninstallSourceNodeRemovalObserver();\n        }\n      });\n\n      if (!node || !node.parentElement) {\n        return;\n      }\n\n      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n        childList: true\n      });\n    }\n  }, {\n    key: \"resurrectSourceNode\",\n    value: function resurrectSourceNode() {\n      if (this.document && this.draggedSourceNode) {\n        this.draggedSourceNode.style.display = 'none';\n        this.draggedSourceNode.removeAttribute('data-reactid');\n        this.document.body.appendChild(this.draggedSourceNode);\n      }\n    }\n  }, {\n    key: \"uninstallSourceNodeRemovalObserver\",\n    value: function uninstallSourceNodeRemovalObserver() {\n      if (this.draggedSourceNodeRemovalObserver) {\n        this.draggedSourceNodeRemovalObserver.disconnect();\n      }\n\n      this.draggedSourceNodeRemovalObserver = undefined;\n      this.draggedSourceNode = undefined;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.options.window;\n    } // public for test\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      if (this.window) {\n        return this.window.document;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return TouchBackendImpl;\n}();","map":{"version":3,"names":["_eventNames","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","invariant","ListenerType","eventShouldStartDrag","eventShouldEndDrag","isTouchEvent","getEventClientOffset","getNodeClientOffset","distance","inAngleRanges","supportsPassive","OptionsReader","eventNames","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackendImpl","manager","context","options","_this","getSourceClientOffset","sourceId","element","sourceNodes","get","handleTopMoveStartCapture","e","moveStartSourceIds","handleMoveStart","Array","isArray","unshift","handleTopMoveStart","clientOffset","lastTargetTouchFallback","targetTouches","_mouseClientOffset","waitingForDelay","handleTopMoveStartDelay","delay","type","delayTouchStart","delayMouseStart","timeout","setTimeout","bind","handleTopMoveCapture","dragOverTargetIds","handleMove","_evt","targetId","handleTopMove","clearTimeout","document","enableHoverOutsideTarget","_isScrolling","monitor","isDragging","x","y","scrollAngleRanges","hasOwnProperty","touchSlop","undefined","actions","beginDrag","publishSource","sourceNode","getSourceId","installSourceNodeRemovalObserver","publishDragSource","cancelable","preventDefault","dragOverTargetNodes","map","targetNodes","filter","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","push","parentElement","indexOf","orderedDragOverTargetIds","node","_getDropTargetId","id","index","ids","targetNode","contains","reverse","hover","keys","next","done","handleTopMoveEndCapture","didDrop","uninstallSourceNodeRemovalObserver","drop","endDrag","handleCancelOnEscape","getActions","getMonitor","Map","sourcePreviewNodes","sourcePreviewNodeOptions","listenerTypes","enableMouseEvents","enableTouchEvents","enableKeyboardEvents","profile","_this$dragOverTargetI","size","setup","window","isSetUp","addEventListener","getTopMoveStartHandler","ignoreContextMenu","teardown","removeEventListener","subject","event","handler","capture","passive","forEach","listenerType","evt","connectDragSource","_this2","set","delete","connectDragPreview","_this3","connectDropTarget","_this4","coords","clientX","clientY","touches","droppedOn","elementFromPoint","childMatch","body","_this5","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect"],"sources":["E:/Front-End-Challenges/React-Challenges/Completed Challenges/ReactTodo/node_modules/rdndmb-html5-to-touch/node_modules/react-dnd-touch-backend/dist/esm/TouchBackendImpl.js"],"sourcesContent":["var _eventNames;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces';\nimport { eventShouldStartDrag, eventShouldEndDrag, isTouchEvent } from './utils/predicates';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets';\nimport { distance, inAngleRanges } from './utils/math';\nimport { supportsPassive } from './utils/supportsPassive';\nimport { OptionsReader } from './OptionsReader';\nvar eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}), _defineProperty(_eventNames, ListenerType.touch, {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}), _defineProperty(_eventNames, ListenerType.keyboard, {\n  keydown: 'keydown'\n}), _eventNames);\nexport var TouchBackendImpl = /*#__PURE__*/function () {\n  function TouchBackendImpl(manager, context, options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchBackendImpl);\n\n    this.getSourceClientOffset = function (sourceId) {\n      var element = _this.sourceNodes.get(sourceId);\n\n      return element && getNodeClientOffset(element);\n    };\n\n    this.handleTopMoveStartCapture = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      _this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      var clientOffset = getEventClientOffset(e);\n\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          _this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n\n        _this._mouseClientOffset = clientOffset;\n      }\n\n      _this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = function (_evt, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = function (e) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n\n      var moveStartSourceIds = _this.moveStartSourceIds,\n          dragOverTargetIds = _this.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = getEventClientOffset(e, _this.lastTargetTouchFallback);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!_this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n\n      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());\n\n      _this.installSourceNodeRemovalObserver(sourceNode);\n\n      _this.actions.publishDragSource();\n\n      if (e.cancelable) e.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes.get(key);\n      }).filter(function (e) {\n        return !!e;\n      }); // Get the a ordered list of nodes that are touched by\n\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      var elementsAtPointExtended = [];\n\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        var currentNode = elementsAtPoint[nodeId];\n        elementsAtPointExtended.push(currentNode);\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        return _this._getDropTargetId(node);\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      }); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          var targetNode = _this.targetNodes.get(targetId);\n\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n     *\n     * visible for testing\n     */\n\n\n    this._getDropTargetId = function (node) {\n      var keys = _this.targetNodes.keys();\n\n      var next = keys.next();\n\n      while (next.done === false) {\n        var targetId = next.value;\n\n        if (node === _this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n\n      return undefined;\n    };\n\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n      _this.lastTargetTouchFallback = undefined;\n\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      if (e.cancelable) e.preventDefault();\n      _this._mouseClientOffset = {};\n\n      _this.uninstallSourceNodeRemovalObserver();\n\n      _this.actions.drop();\n\n      _this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n\n        _this.uninstallSourceNodeRemovalObserver();\n\n        _this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n  /**\n   * Generate profiling statistics for the HTML5Backend.\n   */\n\n\n  _createClass(TouchBackendImpl, [{\n    key: \"profile\",\n    value: function profile() {\n      var _this$dragOverTargetI;\n\n      return {\n        sourceNodes: this.sourceNodes.size,\n        sourcePreviewNodes: this.sourcePreviewNodes.size,\n        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n        targetNodes: this.targetNodes.size,\n        dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0\n      };\n    } // public for test\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      if (!this.window) {\n        return;\n      }\n\n      invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n      TouchBackendImpl.isSetUp = true;\n      this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n      this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.addEventListener(this.window, 'move', this.handleTopMove);\n      this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (!this.window) {\n        return;\n      }\n\n      TouchBackendImpl.isSetUp = false;\n      this._mouseClientOffset = {};\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n      this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.removeEventListener(this.window, 'move', this.handleTopMove);\n      this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n\n      this.uninstallSourceNodeRemovalObserver();\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.addEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.removeEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"connectDragSource\",\n    value: function connectDragSource(sourceId, node) {\n      var _this2 = this;\n\n      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n      this.sourceNodes.set(sourceId, node);\n      this.addEventListener(node, 'start', handleMoveStart);\n      return function () {\n        _this2.sourceNodes.delete(sourceId);\n\n        _this2.removeEventListener(node, 'start', handleMoveStart);\n      };\n    }\n  }, {\n    key: \"connectDragPreview\",\n    value: function connectDragPreview(sourceId, node, options) {\n      var _this3 = this;\n\n      this.sourcePreviewNodeOptions.set(sourceId, options);\n      this.sourcePreviewNodes.set(sourceId, node);\n      return function () {\n        _this3.sourcePreviewNodes.delete(sourceId);\n\n        _this3.sourcePreviewNodeOptions.delete(sourceId);\n      };\n    }\n  }, {\n    key: \"connectDropTarget\",\n    value: function connectDropTarget(targetId, node) {\n      var _this4 = this;\n\n      if (!this.document) {\n        return function () {\n          /* noop */\n        };\n      }\n\n      var handleMove = function handleMove(e) {\n        if (!_this4.document || !_this4.monitor.isDragging()) {\n          return;\n        }\n\n        var coords;\n        /**\n         * Grab the coordinates for the current mouse/touch position\n         */\n\n        switch (e.type) {\n          case eventNames.mouse.move:\n            coords = {\n              x: e.clientX,\n              y: e.clientY\n            };\n            break;\n\n          case eventNames.touch.move:\n            coords = {\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY\n            };\n            break;\n        }\n        /**\n         * Use the coordinates to grab the element the drag ended on.\n         * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n         */\n\n\n        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : undefined;\n        var childMatch = droppedOn && node.contains(droppedOn);\n\n        if (droppedOn === node || childMatch) {\n          return _this4.handleMove(e, targetId);\n        }\n      };\n      /**\n       * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n       */\n\n\n      this.addEventListener(this.document.body, 'move', handleMove);\n      this.targetNodes.set(targetId, node);\n      return function () {\n        if (_this4.document) {\n          _this4.targetNodes.delete(targetId);\n\n          _this4.removeEventListener(_this4.document.body, 'move', handleMove);\n        }\n      };\n    }\n  }, {\n    key: \"getTopMoveStartHandler\",\n    value: function getTopMoveStartHandler() {\n      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n        return this.handleTopMoveStart;\n      }\n\n      return this.handleTopMoveStartDelay;\n    }\n  }, {\n    key: \"installSourceNodeRemovalObserver\",\n    value: function installSourceNodeRemovalObserver(node) {\n      var _this5 = this;\n\n      this.uninstallSourceNodeRemovalObserver();\n      this.draggedSourceNode = node;\n      this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n        if (node && !node.parentElement) {\n          _this5.resurrectSourceNode();\n\n          _this5.uninstallSourceNodeRemovalObserver();\n        }\n      });\n\n      if (!node || !node.parentElement) {\n        return;\n      }\n\n      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n        childList: true\n      });\n    }\n  }, {\n    key: \"resurrectSourceNode\",\n    value: function resurrectSourceNode() {\n      if (this.document && this.draggedSourceNode) {\n        this.draggedSourceNode.style.display = 'none';\n        this.draggedSourceNode.removeAttribute('data-reactid');\n        this.document.body.appendChild(this.draggedSourceNode);\n      }\n    }\n  }, {\n    key: \"uninstallSourceNodeRemovalObserver\",\n    value: function uninstallSourceNodeRemovalObserver() {\n      if (this.draggedSourceNodeRemovalObserver) {\n        this.draggedSourceNodeRemovalObserver.disconnect();\n      }\n\n      this.draggedSourceNodeRemovalObserver = undefined;\n      this.draggedSourceNode = undefined;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.options.window;\n    } // public for test\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      if (this.window) {\n        return this.window.document;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return TouchBackendImpl;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"module"}